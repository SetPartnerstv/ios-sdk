// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: pb/apis/mobile.model.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Pb_MobileEventType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case mobileEventUnspecified // = 0
  case mobileEventGooglepayIsReadyToPayRequest // = 1
  case mobileEventGooglepayIsReadyToPayResponse // = 2
  case mobileEventGooglepayPaymentDataRequest // = 3
  case mobileEventGooglepayPaymentDataResponse // = 4
  case mobileEventGooglepayPaymentDataError // = 5
  case mobileEventApplepayIsReadyToPayRequest // = 6
  case mobileEventApplepayIsReadyToPayResponse // = 7
  case mobileEventApplepayPaymentDataRequest // = 8
  case mobileEventApplepayPaymentDataResponse // = 9
  case mobileEventApplepayPaymentDataError // = 10
  case UNRECOGNIZED(Int)

  init() {
    self = .mobileEventUnspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .mobileEventUnspecified
    case 1: self = .mobileEventGooglepayIsReadyToPayRequest
    case 2: self = .mobileEventGooglepayIsReadyToPayResponse
    case 3: self = .mobileEventGooglepayPaymentDataRequest
    case 4: self = .mobileEventGooglepayPaymentDataResponse
    case 5: self = .mobileEventGooglepayPaymentDataError
    case 6: self = .mobileEventApplepayIsReadyToPayRequest
    case 7: self = .mobileEventApplepayIsReadyToPayResponse
    case 8: self = .mobileEventApplepayPaymentDataRequest
    case 9: self = .mobileEventApplepayPaymentDataResponse
    case 10: self = .mobileEventApplepayPaymentDataError
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .mobileEventUnspecified: return 0
    case .mobileEventGooglepayIsReadyToPayRequest: return 1
    case .mobileEventGooglepayIsReadyToPayResponse: return 2
    case .mobileEventGooglepayPaymentDataRequest: return 3
    case .mobileEventGooglepayPaymentDataResponse: return 4
    case .mobileEventGooglepayPaymentDataError: return 5
    case .mobileEventApplepayIsReadyToPayRequest: return 6
    case .mobileEventApplepayIsReadyToPayResponse: return 7
    case .mobileEventApplepayPaymentDataRequest: return 8
    case .mobileEventApplepayPaymentDataResponse: return 9
    case .mobileEventApplepayPaymentDataError: return 10
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Pb_MobileEventType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Pb_MobileEventType] = [
    .mobileEventUnspecified,
    .mobileEventGooglepayIsReadyToPayRequest,
    .mobileEventGooglepayIsReadyToPayResponse,
    .mobileEventGooglepayPaymentDataRequest,
    .mobileEventGooglepayPaymentDataResponse,
    .mobileEventGooglepayPaymentDataError,
    .mobileEventApplepayIsReadyToPayRequest,
    .mobileEventApplepayIsReadyToPayResponse,
    .mobileEventApplepayPaymentDataRequest,
    .mobileEventApplepayPaymentDataResponse,
    .mobileEventApplepayPaymentDataError,
  ]
}

#endif  // swift(>=4.2)

struct Pb_MobileEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: Pb_MobileEventType = .mobileEventUnspecified

  var payload: Pb_MobileEvent.OneOf_Payload? = nil

  var error: Pb_MobileError {
    get {
      if case .error(let v)? = payload {return v}
      return Pb_MobileError()
    }
    set {payload = .error(newValue)}
  }

  var isReadyToPayRequest: Pb_IsReadyToPayRequest {
    get {
      if case .isReadyToPayRequest(let v)? = payload {return v}
      return Pb_IsReadyToPayRequest()
    }
    set {payload = .isReadyToPayRequest(newValue)}
  }

  var paymentDataRequest: Pb_PaymentDataRequest {
    get {
      if case .paymentDataRequest(let v)? = payload {return v}
      return Pb_PaymentDataRequest()
    }
    set {payload = .paymentDataRequest(newValue)}
  }

  var isReadyToPay: Bool {
    get {
      if case .isReadyToPay(let v)? = payload {return v}
      return false
    }
    set {payload = .isReadyToPay(newValue)}
  }

  var paymentData: Pb_PaymentData {
    get {
      if case .paymentData(let v)? = payload {return v}
      return Pb_PaymentData()
    }
    set {payload = .paymentData(newValue)}
  }

  var applepayPaymentDataRequest: Pb_ApplePayPaymentDataRequest {
    get {
      if case .applepayPaymentDataRequest(let v)? = payload {return v}
      return Pb_ApplePayPaymentDataRequest()
    }
    set {payload = .applepayPaymentDataRequest(newValue)}
  }

  var applepayPaymentData: Pb_ApplePayPaymentData {
    get {
      if case .applepayPaymentData(let v)? = payload {return v}
      return Pb_ApplePayPaymentData()
    }
    set {payload = .applepayPaymentData(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Payload: Equatable {
    case error(Pb_MobileError)
    case isReadyToPayRequest(Pb_IsReadyToPayRequest)
    case paymentDataRequest(Pb_PaymentDataRequest)
    case isReadyToPay(Bool)
    case paymentData(Pb_PaymentData)
    case applepayPaymentDataRequest(Pb_ApplePayPaymentDataRequest)
    case applepayPaymentData(Pb_ApplePayPaymentData)

  #if !swift(>=4.1)
    static func ==(lhs: Pb_MobileEvent.OneOf_Payload, rhs: Pb_MobileEvent.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.isReadyToPayRequest, .isReadyToPayRequest): return {
        guard case .isReadyToPayRequest(let l) = lhs, case .isReadyToPayRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.paymentDataRequest, .paymentDataRequest): return {
        guard case .paymentDataRequest(let l) = lhs, case .paymentDataRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.isReadyToPay, .isReadyToPay): return {
        guard case .isReadyToPay(let l) = lhs, case .isReadyToPay(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.paymentData, .paymentData): return {
        guard case .paymentData(let l) = lhs, case .paymentData(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.applepayPaymentDataRequest, .applepayPaymentDataRequest): return {
        guard case .applepayPaymentDataRequest(let l) = lhs, case .applepayPaymentDataRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.applepayPaymentData, .applepayPaymentData): return {
        guard case .applepayPaymentData(let l) = lhs, case .applepayPaymentData(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Pb_IsReadyToPayRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var apiVersion: UInt32 = 0

  var apiVersionMinor: UInt32 = 0

  var allowedPaymentMethods: [Pb_PaymentMethodSpecification] = []

  var existingPaymentMethodRequired: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Pb_PaymentDataRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var merchantInfo: Pb_MerchantInfo {
    get {return _storage._merchantInfo ?? Pb_MerchantInfo()}
    set {_uniqueStorage()._merchantInfo = newValue}
  }
  /// Returns true if `merchantInfo` has been explicitly set.
  var hasMerchantInfo: Bool {return _storage._merchantInfo != nil}
  /// Clears the value of `merchantInfo`. Subsequent reads from it will return its default value.
  mutating func clearMerchantInfo() {_uniqueStorage()._merchantInfo = nil}

  var apiVersion: UInt32 {
    get {return _storage._apiVersion}
    set {_uniqueStorage()._apiVersion = newValue}
  }

  var apiVersionMinor: UInt32 {
    get {return _storage._apiVersionMinor}
    set {_uniqueStorage()._apiVersionMinor = newValue}
  }

  var emailRequired: Bool {
    get {return _storage._emailRequired}
    set {_uniqueStorage()._emailRequired = newValue}
  }

  var shippingAddressRequired: Bool {
    get {return _storage._shippingAddressRequired}
    set {_uniqueStorage()._shippingAddressRequired = newValue}
  }

  var shippingAddressParameters: Pb_ShippingAddressParameters {
    get {return _storage._shippingAddressParameters ?? Pb_ShippingAddressParameters()}
    set {_uniqueStorage()._shippingAddressParameters = newValue}
  }
  /// Returns true if `shippingAddressParameters` has been explicitly set.
  var hasShippingAddressParameters: Bool {return _storage._shippingAddressParameters != nil}
  /// Clears the value of `shippingAddressParameters`. Subsequent reads from it will return its default value.
  mutating func clearShippingAddressParameters() {_uniqueStorage()._shippingAddressParameters = nil}

  var allowedPaymentMethods: [Pb_PaymentMethodSpecification] {
    get {return _storage._allowedPaymentMethods}
    set {_uniqueStorage()._allowedPaymentMethods = newValue}
  }

  var transactionInfo: Pb_TransactionInfo {
    get {return _storage._transactionInfo ?? Pb_TransactionInfo()}
    set {_uniqueStorage()._transactionInfo = newValue}
  }
  /// Returns true if `transactionInfo` has been explicitly set.
  var hasTransactionInfo: Bool {return _storage._transactionInfo != nil}
  /// Clears the value of `transactionInfo`. Subsequent reads from it will return its default value.
  mutating func clearTransactionInfo() {_uniqueStorage()._transactionInfo = nil}

  var shippingOptionRequired: Bool {
    get {return _storage._shippingOptionRequired}
    set {_uniqueStorage()._shippingOptionRequired = newValue}
  }

  var shippingOptionParameters: Pb_ShippingOptionParameters {
    get {return _storage._shippingOptionParameters ?? Pb_ShippingOptionParameters()}
    set {_uniqueStorage()._shippingOptionParameters = newValue}
  }
  /// Returns true if `shippingOptionParameters` has been explicitly set.
  var hasShippingOptionParameters: Bool {return _storage._shippingOptionParameters != nil}
  /// Clears the value of `shippingOptionParameters`. Subsequent reads from it will return its default value.
  mutating func clearShippingOptionParameters() {_uniqueStorage()._shippingOptionParameters = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Pb_MerchantInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var merchantID: String = String()

  var merchantName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Pb_ShippingAddressParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var allowedCountryCodes: [String] = []

  var phoneNumberRequired: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Pb_TransactionInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var transactionID: String = String()

  var currencyCode: String = String()

  var countryCode: String = String()

  var totalPrice: String = String()

  var totalPriceLabel: String = String()

  var totalPriceStatus: String = String()

  var transactionNote: String = String()

  var checkoutOption: String = String()

  var displayItems: [Pb_DisplayItem] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Pb_DisplayItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var label: String = String()

  var type: String = String()

  var price: String = String()

  var status: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Pb_ShippingOptionParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var shippingOptions: [Pb_ShippingOption] = []

  var defaultSelectedOptionID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Pb_ShippingOption {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var label: String = String()

  var description_p: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Pb_PaymentData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var apiVersion: UInt32 {
    get {return _storage._apiVersion}
    set {_uniqueStorage()._apiVersion = newValue}
  }

  var apiVersionMinor: UInt32 {
    get {return _storage._apiVersionMinor}
    set {_uniqueStorage()._apiVersionMinor = newValue}
  }

  var email: String {
    get {return _storage._email}
    set {_uniqueStorage()._email = newValue}
  }

  var shippingAddress: Pb_Address {
    get {return _storage._shippingAddress ?? Pb_Address()}
    set {_uniqueStorage()._shippingAddress = newValue}
  }
  /// Returns true if `shippingAddress` has been explicitly set.
  var hasShippingAddress: Bool {return _storage._shippingAddress != nil}
  /// Clears the value of `shippingAddress`. Subsequent reads from it will return its default value.
  mutating func clearShippingAddress() {_uniqueStorage()._shippingAddress = nil}

  var paymentMethodData: Pb_PaymentMethodData {
    get {return _storage._paymentMethodData ?? Pb_PaymentMethodData()}
    set {_uniqueStorage()._paymentMethodData = newValue}
  }
  /// Returns true if `paymentMethodData` has been explicitly set.
  var hasPaymentMethodData: Bool {return _storage._paymentMethodData != nil}
  /// Clears the value of `paymentMethodData`. Subsequent reads from it will return its default value.
  mutating func clearPaymentMethodData() {_uniqueStorage()._paymentMethodData = nil}

  var shippingOptionData: Pb_SelectionOptionData {
    get {return _storage._shippingOptionData ?? Pb_SelectionOptionData()}
    set {_uniqueStorage()._shippingOptionData = newValue}
  }
  /// Returns true if `shippingOptionData` has been explicitly set.
  var hasShippingOptionData: Bool {return _storage._shippingOptionData != nil}
  /// Clears the value of `shippingOptionData`. Subsequent reads from it will return its default value.
  mutating func clearShippingOptionData() {_uniqueStorage()._shippingOptionData = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Pb_SelectionOptionData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Pb_PaymentMethodData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: String = String()

  var info: Pb_CardInfo {
    get {return _info ?? Pb_CardInfo()}
    set {_info = newValue}
  }
  /// Returns true if `info` has been explicitly set.
  var hasInfo: Bool {return self._info != nil}
  /// Clears the value of `info`. Subsequent reads from it will return its default value.
  mutating func clearInfo() {self._info = nil}

  var description_p: String = String()

  var tokenizationData: Pb_PaymentMethodTokenizationData {
    get {return _tokenizationData ?? Pb_PaymentMethodTokenizationData()}
    set {_tokenizationData = newValue}
  }
  /// Returns true if `tokenizationData` has been explicitly set.
  var hasTokenizationData: Bool {return self._tokenizationData != nil}
  /// Clears the value of `tokenizationData`. Subsequent reads from it will return its default value.
  mutating func clearTokenizationData() {self._tokenizationData = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _info: Pb_CardInfo? = nil
  fileprivate var _tokenizationData: Pb_PaymentMethodTokenizationData? = nil
}

struct Pb_CardInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cardNetwork: String = String()

  var cardDetails: String = String()

  var billingAddress: Pb_Address {
    get {return _billingAddress ?? Pb_Address()}
    set {_billingAddress = newValue}
  }
  /// Returns true if `billingAddress` has been explicitly set.
  var hasBillingAddress: Bool {return self._billingAddress != nil}
  /// Clears the value of `billingAddress`. Subsequent reads from it will return its default value.
  mutating func clearBillingAddress() {self._billingAddress = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _billingAddress: Pb_Address? = nil
}

struct Pb_Address {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  var address1: String = String()

  var address2: String = String()

  var address3: String = String()

  var locality: String = String()

  var administrativeArea: String = String()

  var countryCode: String = String()

  var postalCode: String = String()

  var sortingCode: String = String()

  var phoneNumber: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Pb_PaymentMethodTokenizationData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: String = String()

  var token: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Pb_PaymentMethodSpecification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: String = String()

  var parameters: Pb_CardParameters {
    get {return _parameters ?? Pb_CardParameters()}
    set {_parameters = newValue}
  }
  /// Returns true if `parameters` has been explicitly set.
  var hasParameters: Bool {return self._parameters != nil}
  /// Clears the value of `parameters`. Subsequent reads from it will return its default value.
  mutating func clearParameters() {self._parameters = nil}

  var tokenizationSpecification: Pb_TokenizationSpecification {
    get {return _tokenizationSpecification ?? Pb_TokenizationSpecification()}
    set {_tokenizationSpecification = newValue}
  }
  /// Returns true if `tokenizationSpecification` has been explicitly set.
  var hasTokenizationSpecification: Bool {return self._tokenizationSpecification != nil}
  /// Clears the value of `tokenizationSpecification`. Subsequent reads from it will return its default value.
  mutating func clearTokenizationSpecification() {self._tokenizationSpecification = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _parameters: Pb_CardParameters? = nil
  fileprivate var _tokenizationSpecification: Pb_TokenizationSpecification? = nil
}

struct Pb_CardParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var allowedAuthMethods: [String] = []

  var allowedCardNetworks: [String] = []

  var allowPrepaidCards: Bool = false

  var allowCreditCards: Bool = false

  var billingAddressRequired: Bool = false

  var billingAddressParameters: Pb_BillingAddressParameters {
    get {return _billingAddressParameters ?? Pb_BillingAddressParameters()}
    set {_billingAddressParameters = newValue}
  }
  /// Returns true if `billingAddressParameters` has been explicitly set.
  var hasBillingAddressParameters: Bool {return self._billingAddressParameters != nil}
  /// Clears the value of `billingAddressParameters`. Subsequent reads from it will return its default value.
  mutating func clearBillingAddressParameters() {self._billingAddressParameters = nil}

  var cardNetworkParameters: Pb_CardNetworkParameters {
    get {return _cardNetworkParameters ?? Pb_CardNetworkParameters()}
    set {_cardNetworkParameters = newValue}
  }
  /// Returns true if `cardNetworkParameters` has been explicitly set.
  var hasCardNetworkParameters: Bool {return self._cardNetworkParameters != nil}
  /// Clears the value of `cardNetworkParameters`. Subsequent reads from it will return its default value.
  mutating func clearCardNetworkParameters() {self._cardNetworkParameters = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _billingAddressParameters: Pb_BillingAddressParameters? = nil
  fileprivate var _cardNetworkParameters: Pb_CardNetworkParameters? = nil
}

struct Pb_TokenizationSpecification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: String = String()

  var parameters: Dictionary<String,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Pb_BillingAddressParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var format: String = String()

  var phoneNumberRequired: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Pb_CardNetworkParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cardNetwork: String = String()

  var acquirerBin: String = String()

  var acquirerMerchantID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Pb_MobileError {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var code: UInt32 = 0

  var message: String = String()

  var description_p: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Pb_ApplePayPaymentDataRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var countryCode: String = String()

  var currencyCode: String = String()

  var total: Pb_ApplePayTotal {
    get {return _total ?? Pb_ApplePayTotal()}
    set {_total = newValue}
  }
  /// Returns true if `total` has been explicitly set.
  var hasTotal: Bool {return self._total != nil}
  /// Clears the value of `total`. Subsequent reads from it will return its default value.
  mutating func clearTotal() {self._total = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _total: Pb_ApplePayTotal? = nil
}

struct Pb_ApplePayTotal {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var label: String = String()

  var amount: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Pb_ApplePayPaymentData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var token: Pb_ApplePayPaymentToken {
    get {return _token ?? Pb_ApplePayPaymentToken()}
    set {_token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  var hasToken: Bool {return self._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  mutating func clearToken() {self._token = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _token: Pb_ApplePayPaymentToken? = nil
}

struct Pb_ApplePayPaymentToken {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var paymentData: String = String()

  var transactionIdentifier: String = String()

  var paymentMethod: Pb_ApplePaymentMethod {
    get {return _paymentMethod ?? Pb_ApplePaymentMethod()}
    set {_paymentMethod = newValue}
  }
  /// Returns true if `paymentMethod` has been explicitly set.
  var hasPaymentMethod: Bool {return self._paymentMethod != nil}
  /// Clears the value of `paymentMethod`. Subsequent reads from it will return its default value.
  mutating func clearPaymentMethod() {self._paymentMethod = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _paymentMethod: Pb_ApplePaymentMethod? = nil
}

struct Pb_ApplePaymentMethod {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var displayName: String = String()

  var network: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "pb"

extension Pb_MobileEventType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MOBILE_EVENT_UNSPECIFIED"),
    1: .same(proto: "MOBILE_EVENT_GOOGLEPAY_IS_READY_TO_PAY_REQUEST"),
    2: .same(proto: "MOBILE_EVENT_GOOGLEPAY_IS_READY_TO_PAY_RESPONSE"),
    3: .same(proto: "MOBILE_EVENT_GOOGLEPAY_PAYMENT_DATA_REQUEST"),
    4: .same(proto: "MOBILE_EVENT_GOOGLEPAY_PAYMENT_DATA_RESPONSE"),
    5: .same(proto: "MOBILE_EVENT_GOOGLEPAY_PAYMENT_DATA_ERROR"),
    6: .same(proto: "MOBILE_EVENT_APPLEPAY_IS_READY_TO_PAY_REQUEST"),
    7: .same(proto: "MOBILE_EVENT_APPLEPAY_IS_READY_TO_PAY_RESPONSE"),
    8: .same(proto: "MOBILE_EVENT_APPLEPAY_PAYMENT_DATA_REQUEST"),
    9: .same(proto: "MOBILE_EVENT_APPLEPAY_PAYMENT_DATA_RESPONSE"),
    10: .same(proto: "MOBILE_EVENT_APPLEPAY_PAYMENT_DATA_ERROR"),
  ]
}

extension Pb_MobileEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MobileEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "error"),
    3: .standard(proto: "is_ready_to_pay_request"),
    4: .standard(proto: "payment_data_request"),
    5: .standard(proto: "is_ready_to_pay"),
    6: .standard(proto: "payment_data"),
    7: .standard(proto: "applepay_payment_data_request"),
    8: .standard(proto: "applepay_payment_data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try {
        var v: Pb_MobileError?
        if let current = self.payload {
          try decoder.handleConflictingOneOf()
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.payload = .error(v)}
      }()
      case 3: try {
        var v: Pb_IsReadyToPayRequest?
        if let current = self.payload {
          try decoder.handleConflictingOneOf()
          if case .isReadyToPayRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.payload = .isReadyToPayRequest(v)}
      }()
      case 4: try {
        var v: Pb_PaymentDataRequest?
        if let current = self.payload {
          try decoder.handleConflictingOneOf()
          if case .paymentDataRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.payload = .paymentDataRequest(v)}
      }()
      case 5: try {
        if self.payload != nil {try decoder.handleConflictingOneOf()}
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {self.payload = .isReadyToPay(v)}
      }()
      case 6: try {
        var v: Pb_PaymentData?
        if let current = self.payload {
          try decoder.handleConflictingOneOf()
          if case .paymentData(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.payload = .paymentData(v)}
      }()
      case 7: try {
        var v: Pb_ApplePayPaymentDataRequest?
        if let current = self.payload {
          try decoder.handleConflictingOneOf()
          if case .applepayPaymentDataRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.payload = .applepayPaymentDataRequest(v)}
      }()
      case 8: try {
        var v: Pb_ApplePayPaymentData?
        if let current = self.payload {
          try decoder.handleConflictingOneOf()
          if case .applepayPaymentData(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.payload = .applepayPaymentData(v)}
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .mobileEventUnspecified {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.payload {
    case .error?: try {
      guard case .error(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .isReadyToPayRequest?: try {
      guard case .isReadyToPayRequest(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .paymentDataRequest?: try {
      guard case .paymentDataRequest(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .isReadyToPay?: try {
      guard case .isReadyToPay(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    }()
    case .paymentData?: try {
      guard case .paymentData(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .applepayPaymentDataRequest?: try {
      guard case .applepayPaymentDataRequest(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .applepayPaymentData?: try {
      guard case .applepayPaymentData(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_MobileEvent, rhs: Pb_MobileEvent) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_IsReadyToPayRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IsReadyToPayRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "api_version"),
    2: .standard(proto: "api_version_minor"),
    3: .standard(proto: "allowed_payment_methods"),
    4: .standard(proto: "existing_payment_method_required"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.apiVersion) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.apiVersionMinor) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.allowedPaymentMethods) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.existingPaymentMethodRequired) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.apiVersion != 0 {
      try visitor.visitSingularUInt32Field(value: self.apiVersion, fieldNumber: 1)
    }
    if self.apiVersionMinor != 0 {
      try visitor.visitSingularUInt32Field(value: self.apiVersionMinor, fieldNumber: 2)
    }
    if !self.allowedPaymentMethods.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.allowedPaymentMethods, fieldNumber: 3)
    }
    if self.existingPaymentMethodRequired != false {
      try visitor.visitSingularBoolField(value: self.existingPaymentMethodRequired, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_IsReadyToPayRequest, rhs: Pb_IsReadyToPayRequest) -> Bool {
    if lhs.apiVersion != rhs.apiVersion {return false}
    if lhs.apiVersionMinor != rhs.apiVersionMinor {return false}
    if lhs.allowedPaymentMethods != rhs.allowedPaymentMethods {return false}
    if lhs.existingPaymentMethodRequired != rhs.existingPaymentMethodRequired {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_PaymentDataRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PaymentDataRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "merchant_info"),
    2: .standard(proto: "api_version"),
    3: .standard(proto: "api_version_minor"),
    4: .standard(proto: "email_required"),
    5: .standard(proto: "shipping_address_required"),
    6: .standard(proto: "shipping_address_parameters"),
    7: .standard(proto: "allowed_payment_methods"),
    8: .standard(proto: "transaction_info"),
    9: .standard(proto: "shipping_option_required"),
    10: .standard(proto: "shipping_option_parameters"),
  ]

  fileprivate class _StorageClass {
    var _merchantInfo: Pb_MerchantInfo? = nil
    var _apiVersion: UInt32 = 0
    var _apiVersionMinor: UInt32 = 0
    var _emailRequired: Bool = false
    var _shippingAddressRequired: Bool = false
    var _shippingAddressParameters: Pb_ShippingAddressParameters? = nil
    var _allowedPaymentMethods: [Pb_PaymentMethodSpecification] = []
    var _transactionInfo: Pb_TransactionInfo? = nil
    var _shippingOptionRequired: Bool = false
    var _shippingOptionParameters: Pb_ShippingOptionParameters? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _merchantInfo = source._merchantInfo
      _apiVersion = source._apiVersion
      _apiVersionMinor = source._apiVersionMinor
      _emailRequired = source._emailRequired
      _shippingAddressRequired = source._shippingAddressRequired
      _shippingAddressParameters = source._shippingAddressParameters
      _allowedPaymentMethods = source._allowedPaymentMethods
      _transactionInfo = source._transactionInfo
      _shippingOptionRequired = source._shippingOptionRequired
      _shippingOptionParameters = source._shippingOptionParameters
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._merchantInfo) }()
        case 2: try { try decoder.decodeSingularUInt32Field(value: &_storage._apiVersion) }()
        case 3: try { try decoder.decodeSingularUInt32Field(value: &_storage._apiVersionMinor) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._emailRequired) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._shippingAddressRequired) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._shippingAddressParameters) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._allowedPaymentMethods) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._transactionInfo) }()
        case 9: try { try decoder.decodeSingularBoolField(value: &_storage._shippingOptionRequired) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._shippingOptionParameters) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._merchantInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._apiVersion != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._apiVersion, fieldNumber: 2)
      }
      if _storage._apiVersionMinor != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._apiVersionMinor, fieldNumber: 3)
      }
      if _storage._emailRequired != false {
        try visitor.visitSingularBoolField(value: _storage._emailRequired, fieldNumber: 4)
      }
      if _storage._shippingAddressRequired != false {
        try visitor.visitSingularBoolField(value: _storage._shippingAddressRequired, fieldNumber: 5)
      }
      if let v = _storage._shippingAddressParameters {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if !_storage._allowedPaymentMethods.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._allowedPaymentMethods, fieldNumber: 7)
      }
      if let v = _storage._transactionInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if _storage._shippingOptionRequired != false {
        try visitor.visitSingularBoolField(value: _storage._shippingOptionRequired, fieldNumber: 9)
      }
      if let v = _storage._shippingOptionParameters {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_PaymentDataRequest, rhs: Pb_PaymentDataRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._merchantInfo != rhs_storage._merchantInfo {return false}
        if _storage._apiVersion != rhs_storage._apiVersion {return false}
        if _storage._apiVersionMinor != rhs_storage._apiVersionMinor {return false}
        if _storage._emailRequired != rhs_storage._emailRequired {return false}
        if _storage._shippingAddressRequired != rhs_storage._shippingAddressRequired {return false}
        if _storage._shippingAddressParameters != rhs_storage._shippingAddressParameters {return false}
        if _storage._allowedPaymentMethods != rhs_storage._allowedPaymentMethods {return false}
        if _storage._transactionInfo != rhs_storage._transactionInfo {return false}
        if _storage._shippingOptionRequired != rhs_storage._shippingOptionRequired {return false}
        if _storage._shippingOptionParameters != rhs_storage._shippingOptionParameters {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_MerchantInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MerchantInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "merchant_id"),
    2: .standard(proto: "merchant_name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.merchantID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.merchantName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.merchantID.isEmpty {
      try visitor.visitSingularStringField(value: self.merchantID, fieldNumber: 1)
    }
    if !self.merchantName.isEmpty {
      try visitor.visitSingularStringField(value: self.merchantName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_MerchantInfo, rhs: Pb_MerchantInfo) -> Bool {
    if lhs.merchantID != rhs.merchantID {return false}
    if lhs.merchantName != rhs.merchantName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_ShippingAddressParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ShippingAddressParameters"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "allowed_country_codes"),
    2: .standard(proto: "phone_number_required"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.allowedCountryCodes) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.phoneNumberRequired) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.allowedCountryCodes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.allowedCountryCodes, fieldNumber: 1)
    }
    if self.phoneNumberRequired != false {
      try visitor.visitSingularBoolField(value: self.phoneNumberRequired, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_ShippingAddressParameters, rhs: Pb_ShippingAddressParameters) -> Bool {
    if lhs.allowedCountryCodes != rhs.allowedCountryCodes {return false}
    if lhs.phoneNumberRequired != rhs.phoneNumberRequired {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_TransactionInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransactionInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transaction_id"),
    2: .standard(proto: "currency_code"),
    3: .standard(proto: "country_code"),
    4: .standard(proto: "total_price"),
    5: .standard(proto: "total_price_label"),
    6: .standard(proto: "total_price_status"),
    7: .standard(proto: "transaction_note"),
    8: .standard(proto: "checkout_option"),
    9: .standard(proto: "display_items"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.transactionID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.currencyCode) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.countryCode) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.totalPrice) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.totalPriceLabel) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.totalPriceStatus) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.transactionNote) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.checkoutOption) }()
      case 9: try { try decoder.decodeRepeatedMessageField(value: &self.displayItems) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transactionID.isEmpty {
      try visitor.visitSingularStringField(value: self.transactionID, fieldNumber: 1)
    }
    if !self.currencyCode.isEmpty {
      try visitor.visitSingularStringField(value: self.currencyCode, fieldNumber: 2)
    }
    if !self.countryCode.isEmpty {
      try visitor.visitSingularStringField(value: self.countryCode, fieldNumber: 3)
    }
    if !self.totalPrice.isEmpty {
      try visitor.visitSingularStringField(value: self.totalPrice, fieldNumber: 4)
    }
    if !self.totalPriceLabel.isEmpty {
      try visitor.visitSingularStringField(value: self.totalPriceLabel, fieldNumber: 5)
    }
    if !self.totalPriceStatus.isEmpty {
      try visitor.visitSingularStringField(value: self.totalPriceStatus, fieldNumber: 6)
    }
    if !self.transactionNote.isEmpty {
      try visitor.visitSingularStringField(value: self.transactionNote, fieldNumber: 7)
    }
    if !self.checkoutOption.isEmpty {
      try visitor.visitSingularStringField(value: self.checkoutOption, fieldNumber: 8)
    }
    if !self.displayItems.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.displayItems, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_TransactionInfo, rhs: Pb_TransactionInfo) -> Bool {
    if lhs.transactionID != rhs.transactionID {return false}
    if lhs.currencyCode != rhs.currencyCode {return false}
    if lhs.countryCode != rhs.countryCode {return false}
    if lhs.totalPrice != rhs.totalPrice {return false}
    if lhs.totalPriceLabel != rhs.totalPriceLabel {return false}
    if lhs.totalPriceStatus != rhs.totalPriceStatus {return false}
    if lhs.transactionNote != rhs.transactionNote {return false}
    if lhs.checkoutOption != rhs.checkoutOption {return false}
    if lhs.displayItems != rhs.displayItems {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_DisplayItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DisplayItem"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
    2: .same(proto: "type"),
    3: .same(proto: "price"),
    4: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.label) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.price) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 1)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 2)
    }
    if !self.price.isEmpty {
      try visitor.visitSingularStringField(value: self.price, fieldNumber: 3)
    }
    if !self.status.isEmpty {
      try visitor.visitSingularStringField(value: self.status, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_DisplayItem, rhs: Pb_DisplayItem) -> Bool {
    if lhs.label != rhs.label {return false}
    if lhs.type != rhs.type {return false}
    if lhs.price != rhs.price {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_ShippingOptionParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ShippingOptionParameters"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "shipping_options"),
    2: .standard(proto: "default_selected_option_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.shippingOptions) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.defaultSelectedOptionID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.shippingOptions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.shippingOptions, fieldNumber: 1)
    }
    if !self.defaultSelectedOptionID.isEmpty {
      try visitor.visitSingularStringField(value: self.defaultSelectedOptionID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_ShippingOptionParameters, rhs: Pb_ShippingOptionParameters) -> Bool {
    if lhs.shippingOptions != rhs.shippingOptions {return false}
    if lhs.defaultSelectedOptionID != rhs.defaultSelectedOptionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_ShippingOption: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ShippingOption"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "label"),
    3: .same(proto: "description"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.label) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_ShippingOption, rhs: Pb_ShippingOption) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.label != rhs.label {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_PaymentData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PaymentData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "api_version"),
    2: .standard(proto: "api_version_minor"),
    3: .same(proto: "email"),
    4: .standard(proto: "shipping_address"),
    5: .standard(proto: "payment_method_data"),
    6: .standard(proto: "shipping_option_data"),
  ]

  fileprivate class _StorageClass {
    var _apiVersion: UInt32 = 0
    var _apiVersionMinor: UInt32 = 0
    var _email: String = String()
    var _shippingAddress: Pb_Address? = nil
    var _paymentMethodData: Pb_PaymentMethodData? = nil
    var _shippingOptionData: Pb_SelectionOptionData? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _apiVersion = source._apiVersion
      _apiVersionMinor = source._apiVersionMinor
      _email = source._email
      _shippingAddress = source._shippingAddress
      _paymentMethodData = source._paymentMethodData
      _shippingOptionData = source._shippingOptionData
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt32Field(value: &_storage._apiVersion) }()
        case 2: try { try decoder.decodeSingularUInt32Field(value: &_storage._apiVersionMinor) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._email) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._shippingAddress) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._paymentMethodData) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._shippingOptionData) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._apiVersion != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._apiVersion, fieldNumber: 1)
      }
      if _storage._apiVersionMinor != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._apiVersionMinor, fieldNumber: 2)
      }
      if !_storage._email.isEmpty {
        try visitor.visitSingularStringField(value: _storage._email, fieldNumber: 3)
      }
      if let v = _storage._shippingAddress {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._paymentMethodData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._shippingOptionData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_PaymentData, rhs: Pb_PaymentData) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._apiVersion != rhs_storage._apiVersion {return false}
        if _storage._apiVersionMinor != rhs_storage._apiVersionMinor {return false}
        if _storage._email != rhs_storage._email {return false}
        if _storage._shippingAddress != rhs_storage._shippingAddress {return false}
        if _storage._paymentMethodData != rhs_storage._paymentMethodData {return false}
        if _storage._shippingOptionData != rhs_storage._shippingOptionData {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_SelectionOptionData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SelectionOptionData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_SelectionOptionData, rhs: Pb_SelectionOptionData) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_PaymentMethodData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PaymentMethodData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "info"),
    3: .same(proto: "description"),
    4: .standard(proto: "tokenization_data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._tokenizationData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if let v = self._tokenizationData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_PaymentMethodData, rhs: Pb_PaymentMethodData) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs._info != rhs._info {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs._tokenizationData != rhs._tokenizationData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_CardInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CardInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "card_network"),
    2: .standard(proto: "card_details"),
    3: .standard(proto: "billing_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.cardNetwork) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.cardDetails) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._billingAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cardNetwork.isEmpty {
      try visitor.visitSingularStringField(value: self.cardNetwork, fieldNumber: 1)
    }
    if !self.cardDetails.isEmpty {
      try visitor.visitSingularStringField(value: self.cardDetails, fieldNumber: 2)
    }
    if let v = self._billingAddress {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_CardInfo, rhs: Pb_CardInfo) -> Bool {
    if lhs.cardNetwork != rhs.cardNetwork {return false}
    if lhs.cardDetails != rhs.cardDetails {return false}
    if lhs._billingAddress != rhs._billingAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_Address: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Address"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "address1"),
    3: .same(proto: "address2"),
    4: .same(proto: "address3"),
    5: .same(proto: "locality"),
    6: .standard(proto: "administrative_area"),
    7: .standard(proto: "country_code"),
    8: .standard(proto: "postal_code"),
    9: .standard(proto: "sorting_code"),
    10: .standard(proto: "phone_number"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.address1) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.address2) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.address3) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.locality) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.administrativeArea) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.countryCode) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.postalCode) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.sortingCode) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.phoneNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.address1.isEmpty {
      try visitor.visitSingularStringField(value: self.address1, fieldNumber: 2)
    }
    if !self.address2.isEmpty {
      try visitor.visitSingularStringField(value: self.address2, fieldNumber: 3)
    }
    if !self.address3.isEmpty {
      try visitor.visitSingularStringField(value: self.address3, fieldNumber: 4)
    }
    if !self.locality.isEmpty {
      try visitor.visitSingularStringField(value: self.locality, fieldNumber: 5)
    }
    if !self.administrativeArea.isEmpty {
      try visitor.visitSingularStringField(value: self.administrativeArea, fieldNumber: 6)
    }
    if !self.countryCode.isEmpty {
      try visitor.visitSingularStringField(value: self.countryCode, fieldNumber: 7)
    }
    if !self.postalCode.isEmpty {
      try visitor.visitSingularStringField(value: self.postalCode, fieldNumber: 8)
    }
    if !self.sortingCode.isEmpty {
      try visitor.visitSingularStringField(value: self.sortingCode, fieldNumber: 9)
    }
    if !self.phoneNumber.isEmpty {
      try visitor.visitSingularStringField(value: self.phoneNumber, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_Address, rhs: Pb_Address) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.address1 != rhs.address1 {return false}
    if lhs.address2 != rhs.address2 {return false}
    if lhs.address3 != rhs.address3 {return false}
    if lhs.locality != rhs.locality {return false}
    if lhs.administrativeArea != rhs.administrativeArea {return false}
    if lhs.countryCode != rhs.countryCode {return false}
    if lhs.postalCode != rhs.postalCode {return false}
    if lhs.sortingCode != rhs.sortingCode {return false}
    if lhs.phoneNumber != rhs.phoneNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_PaymentMethodTokenizationData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PaymentMethodTokenizationData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.token) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_PaymentMethodTokenizationData, rhs: Pb_PaymentMethodTokenizationData) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_PaymentMethodSpecification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PaymentMethodSpecification"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "parameters"),
    3: .standard(proto: "tokenization_specification"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._parameters) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._tokenizationSpecification) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if let v = self._parameters {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._tokenizationSpecification {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_PaymentMethodSpecification, rhs: Pb_PaymentMethodSpecification) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs._parameters != rhs._parameters {return false}
    if lhs._tokenizationSpecification != rhs._tokenizationSpecification {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_CardParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CardParameters"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "allowed_auth_methods"),
    2: .standard(proto: "allowed_card_networks"),
    3: .standard(proto: "allow_prepaid_cards"),
    4: .standard(proto: "allow_credit_cards"),
    5: .standard(proto: "billing_address_required"),
    6: .standard(proto: "billing_address_parameters"),
    7: .standard(proto: "card_network_parameters"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.allowedAuthMethods) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.allowedCardNetworks) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.allowPrepaidCards) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.allowCreditCards) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.billingAddressRequired) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._billingAddressParameters) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._cardNetworkParameters) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.allowedAuthMethods.isEmpty {
      try visitor.visitRepeatedStringField(value: self.allowedAuthMethods, fieldNumber: 1)
    }
    if !self.allowedCardNetworks.isEmpty {
      try visitor.visitRepeatedStringField(value: self.allowedCardNetworks, fieldNumber: 2)
    }
    if self.allowPrepaidCards != false {
      try visitor.visitSingularBoolField(value: self.allowPrepaidCards, fieldNumber: 3)
    }
    if self.allowCreditCards != false {
      try visitor.visitSingularBoolField(value: self.allowCreditCards, fieldNumber: 4)
    }
    if self.billingAddressRequired != false {
      try visitor.visitSingularBoolField(value: self.billingAddressRequired, fieldNumber: 5)
    }
    if let v = self._billingAddressParameters {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if let v = self._cardNetworkParameters {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_CardParameters, rhs: Pb_CardParameters) -> Bool {
    if lhs.allowedAuthMethods != rhs.allowedAuthMethods {return false}
    if lhs.allowedCardNetworks != rhs.allowedCardNetworks {return false}
    if lhs.allowPrepaidCards != rhs.allowPrepaidCards {return false}
    if lhs.allowCreditCards != rhs.allowCreditCards {return false}
    if lhs.billingAddressRequired != rhs.billingAddressRequired {return false}
    if lhs._billingAddressParameters != rhs._billingAddressParameters {return false}
    if lhs._cardNetworkParameters != rhs._cardNetworkParameters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_TokenizationSpecification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TokenizationSpecification"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "parameters"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.parameters) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if !self.parameters.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.parameters, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_TokenizationSpecification, rhs: Pb_TokenizationSpecification) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.parameters != rhs.parameters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_BillingAddressParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BillingAddressParameters"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "format"),
    2: .standard(proto: "phone_number_required"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.format) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.phoneNumberRequired) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.format.isEmpty {
      try visitor.visitSingularStringField(value: self.format, fieldNumber: 1)
    }
    if self.phoneNumberRequired != false {
      try visitor.visitSingularBoolField(value: self.phoneNumberRequired, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_BillingAddressParameters, rhs: Pb_BillingAddressParameters) -> Bool {
    if lhs.format != rhs.format {return false}
    if lhs.phoneNumberRequired != rhs.phoneNumberRequired {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_CardNetworkParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CardNetworkParameters"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "card_network"),
    2: .standard(proto: "acquirer_bin"),
    3: .standard(proto: "acquirer_merchant_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.cardNetwork) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.acquirerBin) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.acquirerMerchantID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cardNetwork.isEmpty {
      try visitor.visitSingularStringField(value: self.cardNetwork, fieldNumber: 1)
    }
    if !self.acquirerBin.isEmpty {
      try visitor.visitSingularStringField(value: self.acquirerBin, fieldNumber: 2)
    }
    if !self.acquirerMerchantID.isEmpty {
      try visitor.visitSingularStringField(value: self.acquirerMerchantID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_CardNetworkParameters, rhs: Pb_CardNetworkParameters) -> Bool {
    if lhs.cardNetwork != rhs.cardNetwork {return false}
    if lhs.acquirerBin != rhs.acquirerBin {return false}
    if lhs.acquirerMerchantID != rhs.acquirerMerchantID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_MobileError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MobileError"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
    3: .same(proto: "description"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != 0 {
      try visitor.visitSingularUInt32Field(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_MobileError, rhs: Pb_MobileError) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_ApplePayPaymentDataRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ApplePayPaymentDataRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "country_code"),
    2: .same(proto: "currency_code"),
    3: .same(proto: "total"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.countryCode) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.currencyCode) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._total) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.countryCode.isEmpty {
      try visitor.visitSingularStringField(value: self.countryCode, fieldNumber: 1)
    }
    if !self.currencyCode.isEmpty {
      try visitor.visitSingularStringField(value: self.currencyCode, fieldNumber: 2)
    }
    if let v = self._total {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_ApplePayPaymentDataRequest, rhs: Pb_ApplePayPaymentDataRequest) -> Bool {
    if lhs.countryCode != rhs.countryCode {return false}
    if lhs.currencyCode != rhs.currencyCode {return false}
    if lhs._total != rhs._total {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_ApplePayTotal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ApplePayTotal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
    2: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.label) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.amount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 1)
    }
    if !self.amount.isEmpty {
      try visitor.visitSingularStringField(value: self.amount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_ApplePayTotal, rhs: Pb_ApplePayTotal) -> Bool {
    if lhs.label != rhs.label {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_ApplePayPaymentData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ApplePayPaymentData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._token) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._token {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_ApplePayPaymentData, rhs: Pb_ApplePayPaymentData) -> Bool {
    if lhs._token != rhs._token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_ApplePayPaymentToken: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ApplePayPaymentToken"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "payment_data"),
    2: .standard(proto: "transaction_identifier"),
    3: .standard(proto: "payment_method"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.paymentData) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.transactionIdentifier) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._paymentMethod) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.paymentData.isEmpty {
      try visitor.visitSingularStringField(value: self.paymentData, fieldNumber: 1)
    }
    if !self.transactionIdentifier.isEmpty {
      try visitor.visitSingularStringField(value: self.transactionIdentifier, fieldNumber: 2)
    }
    if let v = self._paymentMethod {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_ApplePayPaymentToken, rhs: Pb_ApplePayPaymentToken) -> Bool {
    if lhs.paymentData != rhs.paymentData {return false}
    if lhs.transactionIdentifier != rhs.transactionIdentifier {return false}
    if lhs._paymentMethod != rhs._paymentMethod {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_ApplePaymentMethod: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ApplePaymentMethod"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "display_name"),
    2: .same(proto: "network"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.network) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 1)
    }
    if !self.network.isEmpty {
      try visitor.visitSingularStringField(value: self.network, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_ApplePaymentMethod, rhs: Pb_ApplePaymentMethod) -> Bool {
    if lhs.displayName != rhs.displayName {return false}
    if lhs.network != rhs.network {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
