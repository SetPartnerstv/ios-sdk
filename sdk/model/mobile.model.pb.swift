// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: mobile.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Pbv1_MobileEventType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case mobileEventUnspecified // = 0
  case mobileEventGooglepayIsReadyToPayRequest // = 1
  case mobileEventGooglepayIsReadyToPayResponse // = 2
  case mobileEventGooglepayPaymentDataRequest // = 3
  case mobileEventGooglepayPaymentDataResponse // = 4
  case mobileEventGooglepayPaymentDataError // = 5
  case mobileEventApplepayIsReadyToPayRequest // = 6
  case mobileEventApplepayIsReadyToPayResponse // = 7
  case mobileEventApplepayPaymentDataRequest // = 8
  case mobileEventApplepayPaymentDataResponse // = 9
  case mobileEventApplepayPaymentDataError // = 10
  case mobileEventOpenURLRequest // = 11
  case mobileEventBack // = 12
  case mobileEventShareURLRequest // = 13
  case mobileEventGetParamsRequest // = 14
  case mobileEventGetParamsResponse // = 15
  case mobileEventSetParamsRequest // = 16
  case mobileEventCreateKeysRequest // = 17
  case mobileEventCreateKeysResponse // = 18
  case mobileEventParamsUpdated // = 19
  case mobileEventAnalyticsEvent // = 20
  case mobileEventClipboardWrite // = 21
  case mobileEventReview // = 22
  case mobileEventSharePromocodeRequest // = 23
  case mobileEventBrightnessChange // = 24
  case UNRECOGNIZED(Int)

  public init() {
    self = .mobileEventUnspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .mobileEventUnspecified
    case 1: self = .mobileEventGooglepayIsReadyToPayRequest
    case 2: self = .mobileEventGooglepayIsReadyToPayResponse
    case 3: self = .mobileEventGooglepayPaymentDataRequest
    case 4: self = .mobileEventGooglepayPaymentDataResponse
    case 5: self = .mobileEventGooglepayPaymentDataError
    case 6: self = .mobileEventApplepayIsReadyToPayRequest
    case 7: self = .mobileEventApplepayIsReadyToPayResponse
    case 8: self = .mobileEventApplepayPaymentDataRequest
    case 9: self = .mobileEventApplepayPaymentDataResponse
    case 10: self = .mobileEventApplepayPaymentDataError
    case 11: self = .mobileEventOpenURLRequest
    case 12: self = .mobileEventBack
    case 13: self = .mobileEventShareURLRequest
    case 14: self = .mobileEventGetParamsRequest
    case 15: self = .mobileEventGetParamsResponse
    case 16: self = .mobileEventSetParamsRequest
    case 17: self = .mobileEventCreateKeysRequest
    case 18: self = .mobileEventCreateKeysResponse
    case 19: self = .mobileEventParamsUpdated
    case 20: self = .mobileEventAnalyticsEvent
    case 21: self = .mobileEventClipboardWrite
    case 22: self = .mobileEventReview
    case 23: self = .mobileEventSharePromocodeRequest
    case 24: self = .mobileEventBrightnessChange
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .mobileEventUnspecified: return 0
    case .mobileEventGooglepayIsReadyToPayRequest: return 1
    case .mobileEventGooglepayIsReadyToPayResponse: return 2
    case .mobileEventGooglepayPaymentDataRequest: return 3
    case .mobileEventGooglepayPaymentDataResponse: return 4
    case .mobileEventGooglepayPaymentDataError: return 5
    case .mobileEventApplepayIsReadyToPayRequest: return 6
    case .mobileEventApplepayIsReadyToPayResponse: return 7
    case .mobileEventApplepayPaymentDataRequest: return 8
    case .mobileEventApplepayPaymentDataResponse: return 9
    case .mobileEventApplepayPaymentDataError: return 10
    case .mobileEventOpenURLRequest: return 11
    case .mobileEventBack: return 12
    case .mobileEventShareURLRequest: return 13
    case .mobileEventGetParamsRequest: return 14
    case .mobileEventGetParamsResponse: return 15
    case .mobileEventSetParamsRequest: return 16
    case .mobileEventCreateKeysRequest: return 17
    case .mobileEventCreateKeysResponse: return 18
    case .mobileEventParamsUpdated: return 19
    case .mobileEventAnalyticsEvent: return 20
    case .mobileEventClipboardWrite: return 21
    case .mobileEventReview: return 22
    case .mobileEventSharePromocodeRequest: return 23
    case .mobileEventBrightnessChange: return 24
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Pbv1_MobileEventType] = [
    .mobileEventUnspecified,
    .mobileEventGooglepayIsReadyToPayRequest,
    .mobileEventGooglepayIsReadyToPayResponse,
    .mobileEventGooglepayPaymentDataRequest,
    .mobileEventGooglepayPaymentDataResponse,
    .mobileEventGooglepayPaymentDataError,
    .mobileEventApplepayIsReadyToPayRequest,
    .mobileEventApplepayIsReadyToPayResponse,
    .mobileEventApplepayPaymentDataRequest,
    .mobileEventApplepayPaymentDataResponse,
    .mobileEventApplepayPaymentDataError,
    .mobileEventOpenURLRequest,
    .mobileEventBack,
    .mobileEventShareURLRequest,
    .mobileEventGetParamsRequest,
    .mobileEventGetParamsResponse,
    .mobileEventSetParamsRequest,
    .mobileEventCreateKeysRequest,
    .mobileEventCreateKeysResponse,
    .mobileEventParamsUpdated,
    .mobileEventAnalyticsEvent,
    .mobileEventClipboardWrite,
    .mobileEventReview,
    .mobileEventSharePromocodeRequest,
    .mobileEventBrightnessChange,
  ]

}

public enum Pbv1_MobileAnalyticsEventType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unspecified // = 0
  case androidAppInstallReferrer // = 1
  case androidIauInstall // = 2
  case androidIauCancel // = 3
  case loginAppPassword // = 4
  case loginAppBiometry // = 5
  case appBiometryReset // = 6
  case errorAuthBiometry // = 7
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .androidAppInstallReferrer
    case 2: self = .androidIauInstall
    case 3: self = .androidIauCancel
    case 4: self = .loginAppPassword
    case 5: self = .loginAppBiometry
    case 6: self = .appBiometryReset
    case 7: self = .errorAuthBiometry
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .androidAppInstallReferrer: return 1
    case .androidIauInstall: return 2
    case .androidIauCancel: return 3
    case .loginAppPassword: return 4
    case .loginAppBiometry: return 5
    case .appBiometryReset: return 6
    case .errorAuthBiometry: return 7
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Pbv1_MobileAnalyticsEventType] = [
    .unspecified,
    .androidAppInstallReferrer,
    .androidIauInstall,
    .androidIauCancel,
    .loginAppPassword,
    .loginAppBiometry,
    .appBiometryReset,
    .errorAuthBiometry,
  ]

}

public enum Pbv1_MobileAppPromocodeType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unspecified // = 0
  case qr // = 1
  case barcodeean13 // = 2
  case barcodeean8 // = 3
  case barcode128 // = 4
  case promocode // = 5
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .qr
    case 2: self = .barcodeean13
    case 3: self = .barcodeean8
    case 4: self = .barcode128
    case 5: self = .promocode
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .qr: return 1
    case .barcodeean13: return 2
    case .barcodeean8: return 3
    case .barcode128: return 4
    case .promocode: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Pbv1_MobileAppPromocodeType] = [
    .unspecified,
    .qr,
    .barcodeean13,
    .barcodeean8,
    .barcode128,
    .promocode,
  ]

}

public struct Pbv1_MobileEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Pbv1_MobileEventType = .mobileEventUnspecified

  public var payload: Pbv1_MobileEvent.OneOf_Payload? = nil

  public var error: Pbv1_MobileError {
    get {
      if case .error(let v)? = payload {return v}
      return Pbv1_MobileError()
    }
    set {payload = .error(newValue)}
  }

  public var isReadyToPayRequest: Pbv1_IsReadyToPayRequest {
    get {
      if case .isReadyToPayRequest(let v)? = payload {return v}
      return Pbv1_IsReadyToPayRequest()
    }
    set {payload = .isReadyToPayRequest(newValue)}
  }

  public var paymentDataRequest: Pbv1_PaymentDataRequest {
    get {
      if case .paymentDataRequest(let v)? = payload {return v}
      return Pbv1_PaymentDataRequest()
    }
    set {payload = .paymentDataRequest(newValue)}
  }

  public var isReadyToPay: Bool {
    get {
      if case .isReadyToPay(let v)? = payload {return v}
      return false
    }
    set {payload = .isReadyToPay(newValue)}
  }

  public var paymentData: Pbv1_PaymentData {
    get {
      if case .paymentData(let v)? = payload {return v}
      return Pbv1_PaymentData()
    }
    set {payload = .paymentData(newValue)}
  }

  public var applepayPaymentDataRequest: Pbv1_ApplePayPaymentDataRequest {
    get {
      if case .applepayPaymentDataRequest(let v)? = payload {return v}
      return Pbv1_ApplePayPaymentDataRequest()
    }
    set {payload = .applepayPaymentDataRequest(newValue)}
  }

  public var applepayPaymentData: Pbv1_ApplePayPaymentData {
    get {
      if case .applepayPaymentData(let v)? = payload {return v}
      return Pbv1_ApplePayPaymentData()
    }
    set {payload = .applepayPaymentData(newValue)}
  }

  public var openURLRequest: String {
    get {
      if case .openURLRequest(let v)? = payload {return v}
      return String()
    }
    set {payload = .openURLRequest(newValue)}
  }

  public var shareURLRequest: String {
    get {
      if case .shareURLRequest(let v)? = payload {return v}
      return String()
    }
    set {payload = .shareURLRequest(newValue)}
  }

  public var applicationParams: Pbv1_MobileApplicationParams {
    get {
      if case .applicationParams(let v)? = payload {return v}
      return Pbv1_MobileApplicationParams()
    }
    set {payload = .applicationParams(newValue)}
  }

  public var createKeysRequest: Pbv1_CreateKeysRequest {
    get {
      if case .createKeysRequest(let v)? = payload {return v}
      return Pbv1_CreateKeysRequest()
    }
    set {payload = .createKeysRequest(newValue)}
  }

  public var createKeysResponse: Pbv1_CreateKeysResponse {
    get {
      if case .createKeysResponse(let v)? = payload {return v}
      return Pbv1_CreateKeysResponse()
    }
    set {payload = .createKeysResponse(newValue)}
  }

  public var applicationParamsUpdate: Pbv1_MobileApplicationParamsUpdate {
    get {
      if case .applicationParamsUpdate(let v)? = payload {return v}
      return Pbv1_MobileApplicationParamsUpdate()
    }
    set {payload = .applicationParamsUpdate(newValue)}
  }

  public var analyticsEvent: Pbv1_MobileAnalyticsEvent {
    get {
      if case .analyticsEvent(let v)? = payload {return v}
      return Pbv1_MobileAnalyticsEvent()
    }
    set {payload = .analyticsEvent(newValue)}
  }

  public var clipboardWrite: String {
    get {
      if case .clipboardWrite(let v)? = payload {return v}
      return String()
    }
    set {payload = .clipboardWrite(newValue)}
  }

  public var brightness: Int32 {
    get {
      if case .brightness(let v)? = payload {return v}
      return 0
    }
    set {payload = .brightness(newValue)}
  }

  public var promocode: Pbv1_MobileAppPromocodeShare {
    get {
      if case .promocode(let v)? = payload {return v}
      return Pbv1_MobileAppPromocodeShare()
    }
    set {payload = .promocode(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable, Sendable {
    case error(Pbv1_MobileError)
    case isReadyToPayRequest(Pbv1_IsReadyToPayRequest)
    case paymentDataRequest(Pbv1_PaymentDataRequest)
    case isReadyToPay(Bool)
    case paymentData(Pbv1_PaymentData)
    case applepayPaymentDataRequest(Pbv1_ApplePayPaymentDataRequest)
    case applepayPaymentData(Pbv1_ApplePayPaymentData)
    case openURLRequest(String)
    case shareURLRequest(String)
    case applicationParams(Pbv1_MobileApplicationParams)
    case createKeysRequest(Pbv1_CreateKeysRequest)
    case createKeysResponse(Pbv1_CreateKeysResponse)
    case applicationParamsUpdate(Pbv1_MobileApplicationParamsUpdate)
    case analyticsEvent(Pbv1_MobileAnalyticsEvent)
    case clipboardWrite(String)
    case brightness(Int32)
    case promocode(Pbv1_MobileAppPromocodeShare)

  }

  public init() {}
}

public struct Pbv1_IsReadyToPayRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var apiVersion: UInt32 = 0

  public var apiVersionMinor: UInt32 = 0

  public var allowedPaymentMethods: [Pbv1_PaymentMethodSpecification] = []

  public var existingPaymentMethodRequired: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pbv1_PaymentDataRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var merchantInfo: Pbv1_MerchantInfo {
    get {return _storage._merchantInfo ?? Pbv1_MerchantInfo()}
    set {_uniqueStorage()._merchantInfo = newValue}
  }
  /// Returns true if `merchantInfo` has been explicitly set.
  public var hasMerchantInfo: Bool {return _storage._merchantInfo != nil}
  /// Clears the value of `merchantInfo`. Subsequent reads from it will return its default value.
  public mutating func clearMerchantInfo() {_uniqueStorage()._merchantInfo = nil}

  public var apiVersion: UInt32 {
    get {return _storage._apiVersion}
    set {_uniqueStorage()._apiVersion = newValue}
  }

  public var apiVersionMinor: UInt32 {
    get {return _storage._apiVersionMinor}
    set {_uniqueStorage()._apiVersionMinor = newValue}
  }

  public var emailRequired: Bool {
    get {return _storage._emailRequired}
    set {_uniqueStorage()._emailRequired = newValue}
  }

  public var shippingAddressRequired: Bool {
    get {return _storage._shippingAddressRequired}
    set {_uniqueStorage()._shippingAddressRequired = newValue}
  }

  public var shippingAddressParameters: Pbv1_ShippingAddressParameters {
    get {return _storage._shippingAddressParameters ?? Pbv1_ShippingAddressParameters()}
    set {_uniqueStorage()._shippingAddressParameters = newValue}
  }
  /// Returns true if `shippingAddressParameters` has been explicitly set.
  public var hasShippingAddressParameters: Bool {return _storage._shippingAddressParameters != nil}
  /// Clears the value of `shippingAddressParameters`. Subsequent reads from it will return its default value.
  public mutating func clearShippingAddressParameters() {_uniqueStorage()._shippingAddressParameters = nil}

  public var allowedPaymentMethods: [Pbv1_PaymentMethodSpecification] {
    get {return _storage._allowedPaymentMethods}
    set {_uniqueStorage()._allowedPaymentMethods = newValue}
  }

  public var transactionInfo: Pbv1_TransactionInfo {
    get {return _storage._transactionInfo ?? Pbv1_TransactionInfo()}
    set {_uniqueStorage()._transactionInfo = newValue}
  }
  /// Returns true if `transactionInfo` has been explicitly set.
  public var hasTransactionInfo: Bool {return _storage._transactionInfo != nil}
  /// Clears the value of `transactionInfo`. Subsequent reads from it will return its default value.
  public mutating func clearTransactionInfo() {_uniqueStorage()._transactionInfo = nil}

  public var shippingOptionRequired: Bool {
    get {return _storage._shippingOptionRequired}
    set {_uniqueStorage()._shippingOptionRequired = newValue}
  }

  public var shippingOptionParameters: Pbv1_ShippingOptionParameters {
    get {return _storage._shippingOptionParameters ?? Pbv1_ShippingOptionParameters()}
    set {_uniqueStorage()._shippingOptionParameters = newValue}
  }
  /// Returns true if `shippingOptionParameters` has been explicitly set.
  public var hasShippingOptionParameters: Bool {return _storage._shippingOptionParameters != nil}
  /// Clears the value of `shippingOptionParameters`. Subsequent reads from it will return its default value.
  public mutating func clearShippingOptionParameters() {_uniqueStorage()._shippingOptionParameters = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Pbv1_MerchantInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var merchantID: String = String()

  public var merchantName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pbv1_ShippingAddressParameters: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var allowedCountryCodes: [String] = []

  public var phoneNumberRequired: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pbv1_TransactionInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var transactionID: String = String()

  public var currencyCode: String = String()

  public var countryCode: String = String()

  public var totalPrice: String = String()

  public var totalPriceLabel: String = String()

  public var totalPriceStatus: String = String()

  public var transactionNote: String = String()

  public var checkoutOption: String = String()

  public var displayItems: [Pbv1_DisplayItem] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pbv1_DisplayItem: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var label: String = String()

  public var type: String = String()

  public var price: String = String()

  public var status: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pbv1_ShippingOptionParameters: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var shippingOptions: [Pbv1_ShippingOption] = []

  public var defaultSelectedOptionID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pbv1_ShippingOption: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var label: String = String()

  public var description_p: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pbv1_PaymentData: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var apiVersion: UInt32 {
    get {return _storage._apiVersion}
    set {_uniqueStorage()._apiVersion = newValue}
  }

  public var apiVersionMinor: UInt32 {
    get {return _storage._apiVersionMinor}
    set {_uniqueStorage()._apiVersionMinor = newValue}
  }

  public var email: String {
    get {return _storage._email}
    set {_uniqueStorage()._email = newValue}
  }

  public var shippingAddress: Pbv1_Address {
    get {return _storage._shippingAddress ?? Pbv1_Address()}
    set {_uniqueStorage()._shippingAddress = newValue}
  }
  /// Returns true if `shippingAddress` has been explicitly set.
  public var hasShippingAddress: Bool {return _storage._shippingAddress != nil}
  /// Clears the value of `shippingAddress`. Subsequent reads from it will return its default value.
  public mutating func clearShippingAddress() {_uniqueStorage()._shippingAddress = nil}

  public var paymentMethodData: Pbv1_PaymentMethodData {
    get {return _storage._paymentMethodData ?? Pbv1_PaymentMethodData()}
    set {_uniqueStorage()._paymentMethodData = newValue}
  }
  /// Returns true if `paymentMethodData` has been explicitly set.
  public var hasPaymentMethodData: Bool {return _storage._paymentMethodData != nil}
  /// Clears the value of `paymentMethodData`. Subsequent reads from it will return its default value.
  public mutating func clearPaymentMethodData() {_uniqueStorage()._paymentMethodData = nil}

  public var shippingOptionData: Pbv1_SelectionOptionData {
    get {return _storage._shippingOptionData ?? Pbv1_SelectionOptionData()}
    set {_uniqueStorage()._shippingOptionData = newValue}
  }
  /// Returns true if `shippingOptionData` has been explicitly set.
  public var hasShippingOptionData: Bool {return _storage._shippingOptionData != nil}
  /// Clears the value of `shippingOptionData`. Subsequent reads from it will return its default value.
  public mutating func clearShippingOptionData() {_uniqueStorage()._shippingOptionData = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Pbv1_SelectionOptionData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pbv1_PaymentMethodData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: String = String()

  public var info: Pbv1_CardInfo {
    get {return _info ?? Pbv1_CardInfo()}
    set {_info = newValue}
  }
  /// Returns true if `info` has been explicitly set.
  public var hasInfo: Bool {return self._info != nil}
  /// Clears the value of `info`. Subsequent reads from it will return its default value.
  public mutating func clearInfo() {self._info = nil}

  public var description_p: String = String()

  public var tokenizationData: Pbv1_PaymentMethodTokenizationData {
    get {return _tokenizationData ?? Pbv1_PaymentMethodTokenizationData()}
    set {_tokenizationData = newValue}
  }
  /// Returns true if `tokenizationData` has been explicitly set.
  public var hasTokenizationData: Bool {return self._tokenizationData != nil}
  /// Clears the value of `tokenizationData`. Subsequent reads from it will return its default value.
  public mutating func clearTokenizationData() {self._tokenizationData = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _info: Pbv1_CardInfo? = nil
  fileprivate var _tokenizationData: Pbv1_PaymentMethodTokenizationData? = nil
}

public struct Pbv1_CardInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var cardNetwork: String = String()

  public var cardDetails: String = String()

  public var billingAddress: Pbv1_Address {
    get {return _billingAddress ?? Pbv1_Address()}
    set {_billingAddress = newValue}
  }
  /// Returns true if `billingAddress` has been explicitly set.
  public var hasBillingAddress: Bool {return self._billingAddress != nil}
  /// Clears the value of `billingAddress`. Subsequent reads from it will return its default value.
  public mutating func clearBillingAddress() {self._billingAddress = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _billingAddress: Pbv1_Address? = nil
}

public struct Pbv1_Address: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var address1: String = String()

  public var address2: String = String()

  public var address3: String = String()

  public var locality: String = String()

  public var administrativeArea: String = String()

  public var countryCode: String = String()

  public var postalCode: String = String()

  public var sortingCode: String = String()

  public var phoneNumber: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pbv1_PaymentMethodTokenizationData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: String = String()

  public var token: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pbv1_PaymentMethodSpecification: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: String = String()

  public var parameters: Pbv1_CardParameters {
    get {return _parameters ?? Pbv1_CardParameters()}
    set {_parameters = newValue}
  }
  /// Returns true if `parameters` has been explicitly set.
  public var hasParameters: Bool {return self._parameters != nil}
  /// Clears the value of `parameters`. Subsequent reads from it will return its default value.
  public mutating func clearParameters() {self._parameters = nil}

  public var tokenizationSpecification: Pbv1_TokenizationSpecification {
    get {return _tokenizationSpecification ?? Pbv1_TokenizationSpecification()}
    set {_tokenizationSpecification = newValue}
  }
  /// Returns true if `tokenizationSpecification` has been explicitly set.
  public var hasTokenizationSpecification: Bool {return self._tokenizationSpecification != nil}
  /// Clears the value of `tokenizationSpecification`. Subsequent reads from it will return its default value.
  public mutating func clearTokenizationSpecification() {self._tokenizationSpecification = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _parameters: Pbv1_CardParameters? = nil
  fileprivate var _tokenizationSpecification: Pbv1_TokenizationSpecification? = nil
}

public struct Pbv1_CardParameters: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var allowedAuthMethods: [String] = []

  public var allowedCardNetworks: [String] = []

  public var allowPrepaidCards: Bool = false

  public var allowCreditCards: Bool = false

  public var billingAddressRequired: Bool = false

  public var billingAddressParameters: Pbv1_BillingAddressParameters {
    get {return _billingAddressParameters ?? Pbv1_BillingAddressParameters()}
    set {_billingAddressParameters = newValue}
  }
  /// Returns true if `billingAddressParameters` has been explicitly set.
  public var hasBillingAddressParameters: Bool {return self._billingAddressParameters != nil}
  /// Clears the value of `billingAddressParameters`. Subsequent reads from it will return its default value.
  public mutating func clearBillingAddressParameters() {self._billingAddressParameters = nil}

  public var cardNetworkParameters: Pbv1_CardNetworkParameters {
    get {return _cardNetworkParameters ?? Pbv1_CardNetworkParameters()}
    set {_cardNetworkParameters = newValue}
  }
  /// Returns true if `cardNetworkParameters` has been explicitly set.
  public var hasCardNetworkParameters: Bool {return self._cardNetworkParameters != nil}
  /// Clears the value of `cardNetworkParameters`. Subsequent reads from it will return its default value.
  public mutating func clearCardNetworkParameters() {self._cardNetworkParameters = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _billingAddressParameters: Pbv1_BillingAddressParameters? = nil
  fileprivate var _cardNetworkParameters: Pbv1_CardNetworkParameters? = nil
}

public struct Pbv1_TokenizationSpecification: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: String = String()

  public var parameters: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pbv1_BillingAddressParameters: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var format: String = String()

  public var phoneNumberRequired: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pbv1_CardNetworkParameters: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var cardNetwork: String = String()

  public var acquirerBin: String = String()

  public var acquirerMerchantID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pbv1_MobileError: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: UInt32 = 0

  public var message: String = String()

  public var description_p: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pbv1_ApplePayPaymentDataRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var countryCode: String = String()

  public var currencyCode: String = String()

  public var total: Pbv1_ApplePayTotal {
    get {return _total ?? Pbv1_ApplePayTotal()}
    set {_total = newValue}
  }
  /// Returns true if `total` has been explicitly set.
  public var hasTotal: Bool {return self._total != nil}
  /// Clears the value of `total`. Subsequent reads from it will return its default value.
  public mutating func clearTotal() {self._total = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _total: Pbv1_ApplePayTotal? = nil
}

public struct Pbv1_ApplePayTotal: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var label: String = String()

  public var amount: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pbv1_ApplePayPaymentData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var token: Pbv1_ApplePayPaymentToken {
    get {return _token ?? Pbv1_ApplePayPaymentToken()}
    set {_token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  public var hasToken: Bool {return self._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  public mutating func clearToken() {self._token = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _token: Pbv1_ApplePayPaymentToken? = nil
}

public struct Pbv1_ApplePayPaymentToken: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var paymentData: String = String()

  public var transactionIdentifier: String = String()

  public var paymentMethod: Pbv1_ApplePaymentMethod {
    get {return _paymentMethod ?? Pbv1_ApplePaymentMethod()}
    set {_paymentMethod = newValue}
  }
  /// Returns true if `paymentMethod` has been explicitly set.
  public var hasPaymentMethod: Bool {return self._paymentMethod != nil}
  /// Clears the value of `paymentMethod`. Subsequent reads from it will return its default value.
  public mutating func clearPaymentMethod() {self._paymentMethod = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _paymentMethod: Pbv1_ApplePaymentMethod? = nil
}

public struct Pbv1_ApplePaymentMethod: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var displayName: String = String()

  public var network: String = String()

  public var type: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pbv1_MobileApplicationParams: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: String = String()

  public var deviceID: String = String()

  public var confirmationUuid: String = String()

  public var passwordEnabled: Bool = false

  public var biometryEnabled: Bool = false

  public var biometryAvailable: Bool = false

  public var fcmToken: String = String()

  public var myTrackerInstanceID: String = String()

  public var appmetricaDeviceID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pbv1_MobileApplicationParamsUpdate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: String = String()

  public var confirmationUuid: String = String()

  public var passwordEnabled: Bool = false

  public var biometryEnabled: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pbv1_CreateKeysRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var password: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pbv1_CreateKeysResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var publicKey: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pbv1_MobileAnalyticsEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var eventType: Pbv1_MobileAnalyticsEventType = .unspecified

  public var value: String = String()

  public var utmMedium: String = String()

  public var utmSource: String = String()

  public var utmCampaign: String = String()

  public var utmTerm: String = String()

  public var utmContent: String = String()

  /// [(gogoproto.stdtime) = true];
  public var emittedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _emittedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_emittedAt = newValue}
  }
  /// Returns true if `emittedAt` has been explicitly set.
  public var hasEmittedAt: Bool {return self._emittedAt != nil}
  /// Clears the value of `emittedAt`. Subsequent reads from it will return its default value.
  public mutating func clearEmittedAt() {self._emittedAt = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _emittedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Pbv1_MobileAppPromocodeShare: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Pbv1_MobileAppPromocodeType = .unspecified

  public var text: String = String()

  public var valuePromocode: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "pbv1"

extension Pbv1_MobileEventType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MOBILE_EVENT_UNSPECIFIED"),
    1: .same(proto: "MOBILE_EVENT_GOOGLEPAY_IS_READY_TO_PAY_REQUEST"),
    2: .same(proto: "MOBILE_EVENT_GOOGLEPAY_IS_READY_TO_PAY_RESPONSE"),
    3: .same(proto: "MOBILE_EVENT_GOOGLEPAY_PAYMENT_DATA_REQUEST"),
    4: .same(proto: "MOBILE_EVENT_GOOGLEPAY_PAYMENT_DATA_RESPONSE"),
    5: .same(proto: "MOBILE_EVENT_GOOGLEPAY_PAYMENT_DATA_ERROR"),
    6: .same(proto: "MOBILE_EVENT_APPLEPAY_IS_READY_TO_PAY_REQUEST"),
    7: .same(proto: "MOBILE_EVENT_APPLEPAY_IS_READY_TO_PAY_RESPONSE"),
    8: .same(proto: "MOBILE_EVENT_APPLEPAY_PAYMENT_DATA_REQUEST"),
    9: .same(proto: "MOBILE_EVENT_APPLEPAY_PAYMENT_DATA_RESPONSE"),
    10: .same(proto: "MOBILE_EVENT_APPLEPAY_PAYMENT_DATA_ERROR"),
    11: .same(proto: "MOBILE_EVENT_OPEN_URL_REQUEST"),
    12: .same(proto: "MOBILE_EVENT_BACK"),
    13: .same(proto: "MOBILE_EVENT_SHARE_URL_REQUEST"),
    14: .same(proto: "MOBILE_EVENT_GET_PARAMS_REQUEST"),
    15: .same(proto: "MOBILE_EVENT_GET_PARAMS_RESPONSE"),
    16: .same(proto: "MOBILE_EVENT_SET_PARAMS_REQUEST"),
    17: .same(proto: "MOBILE_EVENT_CREATE_KEYS_REQUEST"),
    18: .same(proto: "MOBILE_EVENT_CREATE_KEYS_RESPONSE"),
    19: .same(proto: "MOBILE_EVENT_PARAMS_UPDATED"),
    20: .same(proto: "MOBILE_EVENT_ANALYTICS_EVENT"),
    21: .same(proto: "MOBILE_EVENT_CLIPBOARD_WRITE"),
    22: .same(proto: "MOBILE_EVENT_REVIEW"),
    23: .same(proto: "MOBILE_EVENT_SHARE_PROMOCODE_REQUEST"),
    24: .same(proto: "MOBILE_EVENT_BRIGHTNESS_CHANGE"),
  ]
}

extension Pbv1_MobileAnalyticsEventType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MOBILE_ANALYTICS_EVENT_TYPE_UNSPECIFIED"),
    1: .same(proto: "MOBILE_ANALYTICS_EVENT_TYPE_ANDROID_APP_INSTALL_REFERRER"),
    2: .same(proto: "MOBILE_ANALYTICS_EVENT_TYPE_ANDROID_IAU_INSTALL"),
    3: .same(proto: "MOBILE_ANALYTICS_EVENT_TYPE_ANDROID_IAU_CANCEL"),
    4: .same(proto: "MOBILE_ANALYTICS_EVENT_TYPE_LOGIN_APP_PASSWORD"),
    5: .same(proto: "MOBILE_ANALYTICS_EVENT_TYPE_LOGIN_APP_BIOMETRY"),
    6: .same(proto: "MOBILE_ANALYTICS_EVENT_TYPE_APP_BIOMETRY_RESET"),
    7: .same(proto: "MOBILE_ANALYTICS_EVENT_TYPE_ERROR_AUTH_BIOMETRY"),
  ]
}

extension Pbv1_MobileAppPromocodeType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSPECIFIED"),
    1: .same(proto: "QR"),
    2: .same(proto: "BARCODEEAN13"),
    3: .same(proto: "BARCODEEAN8"),
    4: .same(proto: "BARCODE128"),
    5: .same(proto: "PROMOCODE"),
  ]
}

extension Pbv1_MobileEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MobileEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "error"),
    3: .standard(proto: "is_ready_to_pay_request"),
    4: .standard(proto: "payment_data_request"),
    5: .standard(proto: "is_ready_to_pay"),
    6: .standard(proto: "payment_data"),
    7: .standard(proto: "applepay_payment_data_request"),
    8: .standard(proto: "applepay_payment_data"),
    9: .standard(proto: "open_url_request"),
    10: .standard(proto: "share_url_request"),
    11: .standard(proto: "application_params"),
    12: .standard(proto: "create_keys_request"),
    13: .standard(proto: "create_keys_response"),
    14: .standard(proto: "application_params_update"),
    15: .standard(proto: "analytics_event"),
    16: .standard(proto: "clipboard_write"),
    17: .same(proto: "brightness"),
    18: .same(proto: "promocode"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try {
        var v: Pbv1_MobileError?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .error(v)
        }
      }()
      case 3: try {
        var v: Pbv1_IsReadyToPayRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .isReadyToPayRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .isReadyToPayRequest(v)
        }
      }()
      case 4: try {
        var v: Pbv1_PaymentDataRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .paymentDataRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .paymentDataRequest(v)
        }
      }()
      case 5: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .isReadyToPay(v)
        }
      }()
      case 6: try {
        var v: Pbv1_PaymentData?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .paymentData(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .paymentData(v)
        }
      }()
      case 7: try {
        var v: Pbv1_ApplePayPaymentDataRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .applepayPaymentDataRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .applepayPaymentDataRequest(v)
        }
      }()
      case 8: try {
        var v: Pbv1_ApplePayPaymentData?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .applepayPaymentData(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .applepayPaymentData(v)
        }
      }()
      case 9: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .openURLRequest(v)
        }
      }()
      case 10: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .shareURLRequest(v)
        }
      }()
      case 11: try {
        var v: Pbv1_MobileApplicationParams?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .applicationParams(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .applicationParams(v)
        }
      }()
      case 12: try {
        var v: Pbv1_CreateKeysRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .createKeysRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .createKeysRequest(v)
        }
      }()
      case 13: try {
        var v: Pbv1_CreateKeysResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .createKeysResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .createKeysResponse(v)
        }
      }()
      case 14: try {
        var v: Pbv1_MobileApplicationParamsUpdate?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .applicationParamsUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .applicationParamsUpdate(v)
        }
      }()
      case 15: try {
        var v: Pbv1_MobileAnalyticsEvent?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .analyticsEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .analyticsEvent(v)
        }
      }()
      case 16: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .clipboardWrite(v)
        }
      }()
      case 17: try {
        var v: Int32?
        try decoder.decodeSingularInt32Field(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .brightness(v)
        }
      }()
      case 18: try {
        var v: Pbv1_MobileAppPromocodeShare?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .promocode(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .promocode(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.type != .mobileEventUnspecified {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    switch self.payload {
    case .error?: try {
      guard case .error(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .isReadyToPayRequest?: try {
      guard case .isReadyToPayRequest(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .paymentDataRequest?: try {
      guard case .paymentDataRequest(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .isReadyToPay?: try {
      guard case .isReadyToPay(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    }()
    case .paymentData?: try {
      guard case .paymentData(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .applepayPaymentDataRequest?: try {
      guard case .applepayPaymentDataRequest(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .applepayPaymentData?: try {
      guard case .applepayPaymentData(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .openURLRequest?: try {
      guard case .openURLRequest(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 9)
    }()
    case .shareURLRequest?: try {
      guard case .shareURLRequest(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 10)
    }()
    case .applicationParams?: try {
      guard case .applicationParams(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .createKeysRequest?: try {
      guard case .createKeysRequest(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .createKeysResponse?: try {
      guard case .createKeysResponse(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .applicationParamsUpdate?: try {
      guard case .applicationParamsUpdate(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .analyticsEvent?: try {
      guard case .analyticsEvent(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .clipboardWrite?: try {
      guard case .clipboardWrite(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 16)
    }()
    case .brightness?: try {
      guard case .brightness(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 17)
    }()
    case .promocode?: try {
      guard case .promocode(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbv1_MobileEvent, rhs: Pbv1_MobileEvent) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbv1_IsReadyToPayRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IsReadyToPayRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "api_version"),
    2: .standard(proto: "api_version_minor"),
    3: .standard(proto: "allowed_payment_methods"),
    4: .standard(proto: "existing_payment_method_required"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.apiVersion) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.apiVersionMinor) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.allowedPaymentMethods) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.existingPaymentMethodRequired) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.apiVersion != 0 {
      try visitor.visitSingularUInt32Field(value: self.apiVersion, fieldNumber: 1)
    }
    if self.apiVersionMinor != 0 {
      try visitor.visitSingularUInt32Field(value: self.apiVersionMinor, fieldNumber: 2)
    }
    if !self.allowedPaymentMethods.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.allowedPaymentMethods, fieldNumber: 3)
    }
    if self.existingPaymentMethodRequired != false {
      try visitor.visitSingularBoolField(value: self.existingPaymentMethodRequired, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbv1_IsReadyToPayRequest, rhs: Pbv1_IsReadyToPayRequest) -> Bool {
    if lhs.apiVersion != rhs.apiVersion {return false}
    if lhs.apiVersionMinor != rhs.apiVersionMinor {return false}
    if lhs.allowedPaymentMethods != rhs.allowedPaymentMethods {return false}
    if lhs.existingPaymentMethodRequired != rhs.existingPaymentMethodRequired {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbv1_PaymentDataRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PaymentDataRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "merchant_info"),
    2: .standard(proto: "api_version"),
    3: .standard(proto: "api_version_minor"),
    4: .standard(proto: "email_required"),
    5: .standard(proto: "shipping_address_required"),
    6: .standard(proto: "shipping_address_parameters"),
    7: .standard(proto: "allowed_payment_methods"),
    8: .standard(proto: "transaction_info"),
    9: .standard(proto: "shipping_option_required"),
    10: .standard(proto: "shipping_option_parameters"),
  ]

  fileprivate class _StorageClass {
    var _merchantInfo: Pbv1_MerchantInfo? = nil
    var _apiVersion: UInt32 = 0
    var _apiVersionMinor: UInt32 = 0
    var _emailRequired: Bool = false
    var _shippingAddressRequired: Bool = false
    var _shippingAddressParameters: Pbv1_ShippingAddressParameters? = nil
    var _allowedPaymentMethods: [Pbv1_PaymentMethodSpecification] = []
    var _transactionInfo: Pbv1_TransactionInfo? = nil
    var _shippingOptionRequired: Bool = false
    var _shippingOptionParameters: Pbv1_ShippingOptionParameters? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _merchantInfo = source._merchantInfo
      _apiVersion = source._apiVersion
      _apiVersionMinor = source._apiVersionMinor
      _emailRequired = source._emailRequired
      _shippingAddressRequired = source._shippingAddressRequired
      _shippingAddressParameters = source._shippingAddressParameters
      _allowedPaymentMethods = source._allowedPaymentMethods
      _transactionInfo = source._transactionInfo
      _shippingOptionRequired = source._shippingOptionRequired
      _shippingOptionParameters = source._shippingOptionParameters
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._merchantInfo) }()
        case 2: try { try decoder.decodeSingularUInt32Field(value: &_storage._apiVersion) }()
        case 3: try { try decoder.decodeSingularUInt32Field(value: &_storage._apiVersionMinor) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._emailRequired) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._shippingAddressRequired) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._shippingAddressParameters) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._allowedPaymentMethods) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._transactionInfo) }()
        case 9: try { try decoder.decodeSingularBoolField(value: &_storage._shippingOptionRequired) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._shippingOptionParameters) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._merchantInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if _storage._apiVersion != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._apiVersion, fieldNumber: 2)
      }
      if _storage._apiVersionMinor != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._apiVersionMinor, fieldNumber: 3)
      }
      if _storage._emailRequired != false {
        try visitor.visitSingularBoolField(value: _storage._emailRequired, fieldNumber: 4)
      }
      if _storage._shippingAddressRequired != false {
        try visitor.visitSingularBoolField(value: _storage._shippingAddressRequired, fieldNumber: 5)
      }
      try { if let v = _storage._shippingAddressParameters {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if !_storage._allowedPaymentMethods.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._allowedPaymentMethods, fieldNumber: 7)
      }
      try { if let v = _storage._transactionInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if _storage._shippingOptionRequired != false {
        try visitor.visitSingularBoolField(value: _storage._shippingOptionRequired, fieldNumber: 9)
      }
      try { if let v = _storage._shippingOptionParameters {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbv1_PaymentDataRequest, rhs: Pbv1_PaymentDataRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._merchantInfo != rhs_storage._merchantInfo {return false}
        if _storage._apiVersion != rhs_storage._apiVersion {return false}
        if _storage._apiVersionMinor != rhs_storage._apiVersionMinor {return false}
        if _storage._emailRequired != rhs_storage._emailRequired {return false}
        if _storage._shippingAddressRequired != rhs_storage._shippingAddressRequired {return false}
        if _storage._shippingAddressParameters != rhs_storage._shippingAddressParameters {return false}
        if _storage._allowedPaymentMethods != rhs_storage._allowedPaymentMethods {return false}
        if _storage._transactionInfo != rhs_storage._transactionInfo {return false}
        if _storage._shippingOptionRequired != rhs_storage._shippingOptionRequired {return false}
        if _storage._shippingOptionParameters != rhs_storage._shippingOptionParameters {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbv1_MerchantInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MerchantInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "merchant_id"),
    2: .standard(proto: "merchant_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.merchantID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.merchantName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.merchantID.isEmpty {
      try visitor.visitSingularStringField(value: self.merchantID, fieldNumber: 1)
    }
    if !self.merchantName.isEmpty {
      try visitor.visitSingularStringField(value: self.merchantName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbv1_MerchantInfo, rhs: Pbv1_MerchantInfo) -> Bool {
    if lhs.merchantID != rhs.merchantID {return false}
    if lhs.merchantName != rhs.merchantName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbv1_ShippingAddressParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ShippingAddressParameters"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "allowed_country_codes"),
    2: .standard(proto: "phone_number_required"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.allowedCountryCodes) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.phoneNumberRequired) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.allowedCountryCodes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.allowedCountryCodes, fieldNumber: 1)
    }
    if self.phoneNumberRequired != false {
      try visitor.visitSingularBoolField(value: self.phoneNumberRequired, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbv1_ShippingAddressParameters, rhs: Pbv1_ShippingAddressParameters) -> Bool {
    if lhs.allowedCountryCodes != rhs.allowedCountryCodes {return false}
    if lhs.phoneNumberRequired != rhs.phoneNumberRequired {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbv1_TransactionInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransactionInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transaction_id"),
    2: .standard(proto: "currency_code"),
    3: .standard(proto: "country_code"),
    4: .standard(proto: "total_price"),
    5: .standard(proto: "total_price_label"),
    6: .standard(proto: "total_price_status"),
    7: .standard(proto: "transaction_note"),
    8: .standard(proto: "checkout_option"),
    9: .standard(proto: "display_items"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.transactionID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.currencyCode) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.countryCode) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.totalPrice) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.totalPriceLabel) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.totalPriceStatus) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.transactionNote) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.checkoutOption) }()
      case 9: try { try decoder.decodeRepeatedMessageField(value: &self.displayItems) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transactionID.isEmpty {
      try visitor.visitSingularStringField(value: self.transactionID, fieldNumber: 1)
    }
    if !self.currencyCode.isEmpty {
      try visitor.visitSingularStringField(value: self.currencyCode, fieldNumber: 2)
    }
    if !self.countryCode.isEmpty {
      try visitor.visitSingularStringField(value: self.countryCode, fieldNumber: 3)
    }
    if !self.totalPrice.isEmpty {
      try visitor.visitSingularStringField(value: self.totalPrice, fieldNumber: 4)
    }
    if !self.totalPriceLabel.isEmpty {
      try visitor.visitSingularStringField(value: self.totalPriceLabel, fieldNumber: 5)
    }
    if !self.totalPriceStatus.isEmpty {
      try visitor.visitSingularStringField(value: self.totalPriceStatus, fieldNumber: 6)
    }
    if !self.transactionNote.isEmpty {
      try visitor.visitSingularStringField(value: self.transactionNote, fieldNumber: 7)
    }
    if !self.checkoutOption.isEmpty {
      try visitor.visitSingularStringField(value: self.checkoutOption, fieldNumber: 8)
    }
    if !self.displayItems.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.displayItems, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbv1_TransactionInfo, rhs: Pbv1_TransactionInfo) -> Bool {
    if lhs.transactionID != rhs.transactionID {return false}
    if lhs.currencyCode != rhs.currencyCode {return false}
    if lhs.countryCode != rhs.countryCode {return false}
    if lhs.totalPrice != rhs.totalPrice {return false}
    if lhs.totalPriceLabel != rhs.totalPriceLabel {return false}
    if lhs.totalPriceStatus != rhs.totalPriceStatus {return false}
    if lhs.transactionNote != rhs.transactionNote {return false}
    if lhs.checkoutOption != rhs.checkoutOption {return false}
    if lhs.displayItems != rhs.displayItems {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbv1_DisplayItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DisplayItem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
    2: .same(proto: "type"),
    3: .same(proto: "price"),
    4: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.label) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.price) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 1)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 2)
    }
    if !self.price.isEmpty {
      try visitor.visitSingularStringField(value: self.price, fieldNumber: 3)
    }
    if !self.status.isEmpty {
      try visitor.visitSingularStringField(value: self.status, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbv1_DisplayItem, rhs: Pbv1_DisplayItem) -> Bool {
    if lhs.label != rhs.label {return false}
    if lhs.type != rhs.type {return false}
    if lhs.price != rhs.price {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbv1_ShippingOptionParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ShippingOptionParameters"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "shipping_options"),
    2: .standard(proto: "default_selected_option_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.shippingOptions) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.defaultSelectedOptionID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.shippingOptions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.shippingOptions, fieldNumber: 1)
    }
    if !self.defaultSelectedOptionID.isEmpty {
      try visitor.visitSingularStringField(value: self.defaultSelectedOptionID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbv1_ShippingOptionParameters, rhs: Pbv1_ShippingOptionParameters) -> Bool {
    if lhs.shippingOptions != rhs.shippingOptions {return false}
    if lhs.defaultSelectedOptionID != rhs.defaultSelectedOptionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbv1_ShippingOption: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ShippingOption"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "label"),
    3: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.label) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbv1_ShippingOption, rhs: Pbv1_ShippingOption) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.label != rhs.label {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbv1_PaymentData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PaymentData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "api_version"),
    2: .standard(proto: "api_version_minor"),
    3: .same(proto: "email"),
    4: .standard(proto: "shipping_address"),
    5: .standard(proto: "payment_method_data"),
    6: .standard(proto: "shipping_option_data"),
  ]

  fileprivate class _StorageClass {
    var _apiVersion: UInt32 = 0
    var _apiVersionMinor: UInt32 = 0
    var _email: String = String()
    var _shippingAddress: Pbv1_Address? = nil
    var _paymentMethodData: Pbv1_PaymentMethodData? = nil
    var _shippingOptionData: Pbv1_SelectionOptionData? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _apiVersion = source._apiVersion
      _apiVersionMinor = source._apiVersionMinor
      _email = source._email
      _shippingAddress = source._shippingAddress
      _paymentMethodData = source._paymentMethodData
      _shippingOptionData = source._shippingOptionData
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt32Field(value: &_storage._apiVersion) }()
        case 2: try { try decoder.decodeSingularUInt32Field(value: &_storage._apiVersionMinor) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._email) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._shippingAddress) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._paymentMethodData) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._shippingOptionData) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._apiVersion != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._apiVersion, fieldNumber: 1)
      }
      if _storage._apiVersionMinor != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._apiVersionMinor, fieldNumber: 2)
      }
      if !_storage._email.isEmpty {
        try visitor.visitSingularStringField(value: _storage._email, fieldNumber: 3)
      }
      try { if let v = _storage._shippingAddress {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._paymentMethodData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._shippingOptionData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbv1_PaymentData, rhs: Pbv1_PaymentData) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._apiVersion != rhs_storage._apiVersion {return false}
        if _storage._apiVersionMinor != rhs_storage._apiVersionMinor {return false}
        if _storage._email != rhs_storage._email {return false}
        if _storage._shippingAddress != rhs_storage._shippingAddress {return false}
        if _storage._paymentMethodData != rhs_storage._paymentMethodData {return false}
        if _storage._shippingOptionData != rhs_storage._shippingOptionData {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbv1_SelectionOptionData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SelectionOptionData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbv1_SelectionOptionData, rhs: Pbv1_SelectionOptionData) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbv1_PaymentMethodData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PaymentMethodData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "info"),
    3: .same(proto: "description"),
    4: .standard(proto: "tokenization_data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._tokenizationData) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    try { if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    try { if let v = self._tokenizationData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbv1_PaymentMethodData, rhs: Pbv1_PaymentMethodData) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs._info != rhs._info {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs._tokenizationData != rhs._tokenizationData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbv1_CardInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CardInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "card_network"),
    2: .standard(proto: "card_details"),
    3: .standard(proto: "billing_address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.cardNetwork) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.cardDetails) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._billingAddress) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.cardNetwork.isEmpty {
      try visitor.visitSingularStringField(value: self.cardNetwork, fieldNumber: 1)
    }
    if !self.cardDetails.isEmpty {
      try visitor.visitSingularStringField(value: self.cardDetails, fieldNumber: 2)
    }
    try { if let v = self._billingAddress {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbv1_CardInfo, rhs: Pbv1_CardInfo) -> Bool {
    if lhs.cardNetwork != rhs.cardNetwork {return false}
    if lhs.cardDetails != rhs.cardDetails {return false}
    if lhs._billingAddress != rhs._billingAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbv1_Address: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Address"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "address1"),
    3: .same(proto: "address2"),
    4: .same(proto: "address3"),
    5: .same(proto: "locality"),
    6: .standard(proto: "administrative_area"),
    7: .standard(proto: "country_code"),
    8: .standard(proto: "postal_code"),
    9: .standard(proto: "sorting_code"),
    10: .standard(proto: "phone_number"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.address1) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.address2) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.address3) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.locality) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.administrativeArea) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.countryCode) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.postalCode) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.sortingCode) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.phoneNumber) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.address1.isEmpty {
      try visitor.visitSingularStringField(value: self.address1, fieldNumber: 2)
    }
    if !self.address2.isEmpty {
      try visitor.visitSingularStringField(value: self.address2, fieldNumber: 3)
    }
    if !self.address3.isEmpty {
      try visitor.visitSingularStringField(value: self.address3, fieldNumber: 4)
    }
    if !self.locality.isEmpty {
      try visitor.visitSingularStringField(value: self.locality, fieldNumber: 5)
    }
    if !self.administrativeArea.isEmpty {
      try visitor.visitSingularStringField(value: self.administrativeArea, fieldNumber: 6)
    }
    if !self.countryCode.isEmpty {
      try visitor.visitSingularStringField(value: self.countryCode, fieldNumber: 7)
    }
    if !self.postalCode.isEmpty {
      try visitor.visitSingularStringField(value: self.postalCode, fieldNumber: 8)
    }
    if !self.sortingCode.isEmpty {
      try visitor.visitSingularStringField(value: self.sortingCode, fieldNumber: 9)
    }
    if !self.phoneNumber.isEmpty {
      try visitor.visitSingularStringField(value: self.phoneNumber, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbv1_Address, rhs: Pbv1_Address) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.address1 != rhs.address1 {return false}
    if lhs.address2 != rhs.address2 {return false}
    if lhs.address3 != rhs.address3 {return false}
    if lhs.locality != rhs.locality {return false}
    if lhs.administrativeArea != rhs.administrativeArea {return false}
    if lhs.countryCode != rhs.countryCode {return false}
    if lhs.postalCode != rhs.postalCode {return false}
    if lhs.sortingCode != rhs.sortingCode {return false}
    if lhs.phoneNumber != rhs.phoneNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbv1_PaymentMethodTokenizationData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PaymentMethodTokenizationData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.token) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbv1_PaymentMethodTokenizationData, rhs: Pbv1_PaymentMethodTokenizationData) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbv1_PaymentMethodSpecification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PaymentMethodSpecification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "parameters"),
    3: .standard(proto: "tokenization_specification"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._parameters) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._tokenizationSpecification) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    try { if let v = self._parameters {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._tokenizationSpecification {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbv1_PaymentMethodSpecification, rhs: Pbv1_PaymentMethodSpecification) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs._parameters != rhs._parameters {return false}
    if lhs._tokenizationSpecification != rhs._tokenizationSpecification {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbv1_CardParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CardParameters"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "allowed_auth_methods"),
    2: .standard(proto: "allowed_card_networks"),
    3: .standard(proto: "allow_prepaid_cards"),
    4: .standard(proto: "allow_credit_cards"),
    5: .standard(proto: "billing_address_required"),
    6: .standard(proto: "billing_address_parameters"),
    7: .standard(proto: "card_network_parameters"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.allowedAuthMethods) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.allowedCardNetworks) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.allowPrepaidCards) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.allowCreditCards) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.billingAddressRequired) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._billingAddressParameters) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._cardNetworkParameters) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.allowedAuthMethods.isEmpty {
      try visitor.visitRepeatedStringField(value: self.allowedAuthMethods, fieldNumber: 1)
    }
    if !self.allowedCardNetworks.isEmpty {
      try visitor.visitRepeatedStringField(value: self.allowedCardNetworks, fieldNumber: 2)
    }
    if self.allowPrepaidCards != false {
      try visitor.visitSingularBoolField(value: self.allowPrepaidCards, fieldNumber: 3)
    }
    if self.allowCreditCards != false {
      try visitor.visitSingularBoolField(value: self.allowCreditCards, fieldNumber: 4)
    }
    if self.billingAddressRequired != false {
      try visitor.visitSingularBoolField(value: self.billingAddressRequired, fieldNumber: 5)
    }
    try { if let v = self._billingAddressParameters {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._cardNetworkParameters {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbv1_CardParameters, rhs: Pbv1_CardParameters) -> Bool {
    if lhs.allowedAuthMethods != rhs.allowedAuthMethods {return false}
    if lhs.allowedCardNetworks != rhs.allowedCardNetworks {return false}
    if lhs.allowPrepaidCards != rhs.allowPrepaidCards {return false}
    if lhs.allowCreditCards != rhs.allowCreditCards {return false}
    if lhs.billingAddressRequired != rhs.billingAddressRequired {return false}
    if lhs._billingAddressParameters != rhs._billingAddressParameters {return false}
    if lhs._cardNetworkParameters != rhs._cardNetworkParameters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbv1_TokenizationSpecification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TokenizationSpecification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "parameters"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.parameters) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if !self.parameters.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.parameters, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbv1_TokenizationSpecification, rhs: Pbv1_TokenizationSpecification) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.parameters != rhs.parameters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbv1_BillingAddressParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BillingAddressParameters"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "format"),
    2: .standard(proto: "phone_number_required"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.format) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.phoneNumberRequired) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.format.isEmpty {
      try visitor.visitSingularStringField(value: self.format, fieldNumber: 1)
    }
    if self.phoneNumberRequired != false {
      try visitor.visitSingularBoolField(value: self.phoneNumberRequired, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbv1_BillingAddressParameters, rhs: Pbv1_BillingAddressParameters) -> Bool {
    if lhs.format != rhs.format {return false}
    if lhs.phoneNumberRequired != rhs.phoneNumberRequired {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbv1_CardNetworkParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CardNetworkParameters"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "card_network"),
    2: .standard(proto: "acquirer_bin"),
    3: .standard(proto: "acquirer_merchant_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.cardNetwork) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.acquirerBin) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.acquirerMerchantID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cardNetwork.isEmpty {
      try visitor.visitSingularStringField(value: self.cardNetwork, fieldNumber: 1)
    }
    if !self.acquirerBin.isEmpty {
      try visitor.visitSingularStringField(value: self.acquirerBin, fieldNumber: 2)
    }
    if !self.acquirerMerchantID.isEmpty {
      try visitor.visitSingularStringField(value: self.acquirerMerchantID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbv1_CardNetworkParameters, rhs: Pbv1_CardNetworkParameters) -> Bool {
    if lhs.cardNetwork != rhs.cardNetwork {return false}
    if lhs.acquirerBin != rhs.acquirerBin {return false}
    if lhs.acquirerMerchantID != rhs.acquirerMerchantID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbv1_MobileError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MobileError"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
    3: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != 0 {
      try visitor.visitSingularUInt32Field(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbv1_MobileError, rhs: Pbv1_MobileError) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbv1_ApplePayPaymentDataRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ApplePayPaymentDataRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "country_code"),
    2: .standard(proto: "currency_code"),
    3: .same(proto: "total"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.countryCode) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.currencyCode) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._total) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.countryCode.isEmpty {
      try visitor.visitSingularStringField(value: self.countryCode, fieldNumber: 1)
    }
    if !self.currencyCode.isEmpty {
      try visitor.visitSingularStringField(value: self.currencyCode, fieldNumber: 2)
    }
    try { if let v = self._total {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbv1_ApplePayPaymentDataRequest, rhs: Pbv1_ApplePayPaymentDataRequest) -> Bool {
    if lhs.countryCode != rhs.countryCode {return false}
    if lhs.currencyCode != rhs.currencyCode {return false}
    if lhs._total != rhs._total {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbv1_ApplePayTotal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ApplePayTotal"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
    2: .same(proto: "amount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.label) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.amount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 1)
    }
    if !self.amount.isEmpty {
      try visitor.visitSingularStringField(value: self.amount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbv1_ApplePayTotal, rhs: Pbv1_ApplePayTotal) -> Bool {
    if lhs.label != rhs.label {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbv1_ApplePayPaymentData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ApplePayPaymentData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._token) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._token {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbv1_ApplePayPaymentData, rhs: Pbv1_ApplePayPaymentData) -> Bool {
    if lhs._token != rhs._token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbv1_ApplePayPaymentToken: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ApplePayPaymentToken"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "payment_data"),
    2: .standard(proto: "transaction_identifier"),
    3: .standard(proto: "payment_method"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.paymentData) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.transactionIdentifier) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._paymentMethod) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.paymentData.isEmpty {
      try visitor.visitSingularStringField(value: self.paymentData, fieldNumber: 1)
    }
    if !self.transactionIdentifier.isEmpty {
      try visitor.visitSingularStringField(value: self.transactionIdentifier, fieldNumber: 2)
    }
    try { if let v = self._paymentMethod {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbv1_ApplePayPaymentToken, rhs: Pbv1_ApplePayPaymentToken) -> Bool {
    if lhs.paymentData != rhs.paymentData {return false}
    if lhs.transactionIdentifier != rhs.transactionIdentifier {return false}
    if lhs._paymentMethod != rhs._paymentMethod {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbv1_ApplePaymentMethod: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ApplePaymentMethod"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "display_name"),
    2: .same(proto: "network"),
    3: .same(proto: "type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.network) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.type) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 1)
    }
    if !self.network.isEmpty {
      try visitor.visitSingularStringField(value: self.network, fieldNumber: 2)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbv1_ApplePaymentMethod, rhs: Pbv1_ApplePaymentMethod) -> Bool {
    if lhs.displayName != rhs.displayName {return false}
    if lhs.network != rhs.network {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbv1_MobileApplicationParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MobileApplicationParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .standard(proto: "device_id"),
    3: .standard(proto: "confirmation_uuid"),
    4: .standard(proto: "password_enabled"),
    5: .standard(proto: "biometry_enabled"),
    6: .standard(proto: "biometry_available"),
    7: .standard(proto: "fcm_token"),
    8: .standard(proto: "my_tracker_instance_id"),
    9: .standard(proto: "appmetrica_device_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.confirmationUuid) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.passwordEnabled) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.biometryEnabled) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.biometryAvailable) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.fcmToken) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.myTrackerInstanceID) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.appmetricaDeviceID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 2)
    }
    if !self.confirmationUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.confirmationUuid, fieldNumber: 3)
    }
    if self.passwordEnabled != false {
      try visitor.visitSingularBoolField(value: self.passwordEnabled, fieldNumber: 4)
    }
    if self.biometryEnabled != false {
      try visitor.visitSingularBoolField(value: self.biometryEnabled, fieldNumber: 5)
    }
    if self.biometryAvailable != false {
      try visitor.visitSingularBoolField(value: self.biometryAvailable, fieldNumber: 6)
    }
    if !self.fcmToken.isEmpty {
      try visitor.visitSingularStringField(value: self.fcmToken, fieldNumber: 7)
    }
    if !self.myTrackerInstanceID.isEmpty {
      try visitor.visitSingularStringField(value: self.myTrackerInstanceID, fieldNumber: 8)
    }
    if !self.appmetricaDeviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.appmetricaDeviceID, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbv1_MobileApplicationParams, rhs: Pbv1_MobileApplicationParams) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.confirmationUuid != rhs.confirmationUuid {return false}
    if lhs.passwordEnabled != rhs.passwordEnabled {return false}
    if lhs.biometryEnabled != rhs.biometryEnabled {return false}
    if lhs.biometryAvailable != rhs.biometryAvailable {return false}
    if lhs.fcmToken != rhs.fcmToken {return false}
    if lhs.myTrackerInstanceID != rhs.myTrackerInstanceID {return false}
    if lhs.appmetricaDeviceID != rhs.appmetricaDeviceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbv1_MobileApplicationParamsUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MobileApplicationParamsUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .standard(proto: "confirmation_uuid"),
    3: .standard(proto: "password_enabled"),
    4: .standard(proto: "biometry_enabled"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.confirmationUuid) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.passwordEnabled) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.biometryEnabled) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if !self.confirmationUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.confirmationUuid, fieldNumber: 2)
    }
    if self.passwordEnabled != false {
      try visitor.visitSingularBoolField(value: self.passwordEnabled, fieldNumber: 3)
    }
    if self.biometryEnabled != false {
      try visitor.visitSingularBoolField(value: self.biometryEnabled, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbv1_MobileApplicationParamsUpdate, rhs: Pbv1_MobileApplicationParamsUpdate) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.confirmationUuid != rhs.confirmationUuid {return false}
    if lhs.passwordEnabled != rhs.passwordEnabled {return false}
    if lhs.biometryEnabled != rhs.biometryEnabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbv1_CreateKeysRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateKeysRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "password"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.password) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbv1_CreateKeysRequest, rhs: Pbv1_CreateKeysRequest) -> Bool {
    if lhs.password != rhs.password {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbv1_CreateKeysResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateKeysResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "public_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.publicKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.publicKey.isEmpty {
      try visitor.visitSingularStringField(value: self.publicKey, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbv1_CreateKeysResponse, rhs: Pbv1_CreateKeysResponse) -> Bool {
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbv1_MobileAnalyticsEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MobileAnalyticsEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "event_type"),
    2: .same(proto: "value"),
    3: .standard(proto: "utm_medium"),
    4: .standard(proto: "utm_source"),
    5: .standard(proto: "utm_campaign"),
    6: .standard(proto: "utm_term"),
    7: .standard(proto: "utm_content"),
    8: .standard(proto: "emitted_at"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.eventType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.utmMedium) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.utmSource) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.utmCampaign) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.utmTerm) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.utmContent) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._emittedAt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.eventType != .unspecified {
      try visitor.visitSingularEnumField(value: self.eventType, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    if !self.utmMedium.isEmpty {
      try visitor.visitSingularStringField(value: self.utmMedium, fieldNumber: 3)
    }
    if !self.utmSource.isEmpty {
      try visitor.visitSingularStringField(value: self.utmSource, fieldNumber: 4)
    }
    if !self.utmCampaign.isEmpty {
      try visitor.visitSingularStringField(value: self.utmCampaign, fieldNumber: 5)
    }
    if !self.utmTerm.isEmpty {
      try visitor.visitSingularStringField(value: self.utmTerm, fieldNumber: 6)
    }
    if !self.utmContent.isEmpty {
      try visitor.visitSingularStringField(value: self.utmContent, fieldNumber: 7)
    }
    try { if let v = self._emittedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbv1_MobileAnalyticsEvent, rhs: Pbv1_MobileAnalyticsEvent) -> Bool {
    if lhs.eventType != rhs.eventType {return false}
    if lhs.value != rhs.value {return false}
    if lhs.utmMedium != rhs.utmMedium {return false}
    if lhs.utmSource != rhs.utmSource {return false}
    if lhs.utmCampaign != rhs.utmCampaign {return false}
    if lhs.utmTerm != rhs.utmTerm {return false}
    if lhs.utmContent != rhs.utmContent {return false}
    if lhs._emittedAt != rhs._emittedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pbv1_MobileAppPromocodeShare: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MobileAppPromocodeShare"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "text"),
    3: .standard(proto: "value_promocode"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.valuePromocode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .unspecified {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 2)
    }
    if !self.valuePromocode.isEmpty {
      try visitor.visitSingularStringField(value: self.valuePromocode, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pbv1_MobileAppPromocodeShare, rhs: Pbv1_MobileAppPromocodeShare) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.text != rhs.text {return false}
    if lhs.valuePromocode != rhs.valuePromocode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
